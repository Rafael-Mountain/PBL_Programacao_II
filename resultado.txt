==========================
{src/DiarioCultural.java}
import tests.mocks.MockFilme;
import tests.mocks.MockLivro;
import tests.mocks.MockSerie;
import view.Menu;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;
import java.util.Scanner;

/**
 * Classe principal do sistema DiarioCultural.
 *
 * <p>Responsável por iniciar a aplicação, carregando opcionalmente dados de teste e exibindo
 * a interface de menu no terminal.</p>
 *
 * <p>O comportamento de inicialização com dados de teste pode ser controlado por meio de um
 * arquivo de configuração externo {@code config.properties}. Este arquivo deve conter a propriedade
 * {@code teste}, cujo valor define se os métodos de simulação de dados {@code MockFilme},
 * {@code MockLivro} e {@code MockSerie} serão executados.</p>
 *
 * <p>Exemplo de conteúdo do arquivo {@code config.properties}:</p>
 * <pre>
 * teste=true
 * </pre>
 *
 * <p>Se o arquivo de configuração estiver ausente ou ocorrer algum erro durante a leitura,
 * o programa prosseguirá com {@code teste = false} por padrão.</p>
 *
 * <p>Após a execução dos testes (se habilitados), é criada uma instância do menu principal
 * da aplicação, que permite a interação do usuário através do terminal.</p>
 *
 * @author Rafael Henrique e Vitor Gabriel
 * @version 1.0
 * @since 2025-04-23
 */
public class DiarioCultural {

    /**
     * Ponto de entrada da aplicação DiarioCultural.
     *
     * <p>Carrega as configurações a partir do arquivo {@code config.properties}, executa os dados de teste
     * se habilitados, e inicia a interface de menu via terminal.</p>
     *
     * @param args argumentos de linha de comando (não utilizados atualmente).
     */
    public static void main(String[] args) {
        boolean teste = false;


        Properties props = new Properties();
        try (FileInputStream input = new FileInputStream("config.properties")) {
            props.load(input);
            teste = Boolean.parseBoolean(props.getProperty("teste", "false"));
        } catch (IOException e) {
            System.out.println("Arquivo de configuração não encontrado ou inválido. Continuando com teste = false.");
        }

        // Executa dados de teste se a configuração permitir
        if (teste) {
            MockFilme.rodar();
            MockLivro.rodar();
            MockSerie.rodar();
        }

        // Inicializa o menu principal
        Scanner terminal = new Scanner(System.in);
        new Menu().draw(terminal);
    }
}

=========================

==========================
{src/controller/action/Action.java}
package controller.action;

/**
 * Interface que define uma ação a ser executada sobre um modelo.
 *
 * Esta interface representa uma ação genérica que pode ser aplicada a qualquer tipo de modelo. A ação executa um processo sobre o modelo fornecido e retorna um resultado de ação.
 *
 * @param <T> O tipo de modelo que a ação irá processar.
 *
 * @see ActionResult
 */
public interface Action<T> {

    /**
     * Executa a ação sobre o modelo fornecido.
     *
     * Este método deve ser implementado por classes que definem ações específicas a serem realizadas sobre um modelo.
     * O modelo é passado como parâmetro, e o método retorna um resultado de ação que pode indicar sucesso ou falha.
     *
     * @param model O modelo sobre o qual a ação será executada.
     * @return O resultado da execução da ação, que pode indicar sucesso ou falha.
     */
    ActionResult execute(T model);
}

=========================

==========================
{src/controller/action/ActionResult.java}
package controller.action;

/**
 * Representa o resultado de uma ação executada.
 *
 * A classe `ActionResult` armazena informações sobre o sucesso ou falha de uma ação, juntamente com uma mensagem que pode fornecer mais detalhes sobre o resultado.
 * Esta classe é usada para retornar o resultado de ações executadas sobre um modelo, como a criação, atualização ou remoção de um objeto.
 */
public class ActionResult {

    private final boolean success;
    private final String message;

    /**
     * Constrói um novo `ActionResult` com o status de sucesso e uma mensagem.
     *
     * @param success O status da ação (verdadeiro se a ação foi bem-sucedida, falso caso contrário).
     * @param message Uma mensagem explicativa sobre o resultado da ação.
     */
    public ActionResult(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    /**
     * Retorna o status de sucesso da ação.
     *
     * @return `true` se a ação foi bem-sucedida, `false` caso contrário.
     */
    public boolean isSuccess() {
        return success;
    }

    /**
     * Retorna a mensagem explicativa sobre o resultado da ação.
     *
     * @return A mensagem associada ao resultado da ação.
     */
    public String getMessage() {
        return message;
    }

    /**
     * Retorna uma representação em formato de string do resultado da ação.
     *
     * A string contém o status de sucesso e a mensagem associada ao resultado da ação.
     *
     * @return Uma string representando o `ActionResult`.
     */
    @Override
    public String toString() {
        return "ActionResult{success=" + success + ", message='" + message + "'}";
    }
}

=========================

==========================
{src/controller/action/BaseAction.java}
package controller.action;

/**
 * Representa a ação base que executa uma operação sobre um modelo genérico.
 *
 * A classe `BaseAction` implementa a interface `Action` e fornece a funcionalidade básica para validar modelos antes de executar uma ação. Ela utiliza um mecanismo de validação, que é passado como parâmetro no construtor, para garantir que as condições necessárias sejam atendidas antes de realizar a ação.
 *
 * As subclasses de `BaseAction` devem fornecer a implementação específica de como a ação será executada no modelo.
 *
 * @param <T> O tipo de modelo sobre o qual a ação será executada.
 */
public abstract class BaseAction<T> implements Action<T> {

    /**
     * O validador utilizado para validar o modelo antes de realizar a ação.
     */
    protected final Validation<T> validation;

    /**
     * Constrói uma nova instância de `BaseAction` com o validador fornecido.
     *
     * @param validation O validador a ser utilizado para validar o modelo antes de executar a ação.
     */
    public BaseAction(Validation<T> validation) {
        this.validation = validation;
    }

    /**
     * Valida o modelo fornecido utilizando o validador.
     *
     * @param model O modelo a ser validado.
     * @return `true` se o modelo for válido, caso contrário `false`.
     */
    protected boolean isValid(T model) {
        return validation.isValid(model);
    }

    /**
     * Obtém a mensagem de erro associada à falha de validação, caso o modelo não seja válido.
     *
     * @return A mensagem de erro explicando por que o modelo é inválido.
     */
    protected String getErrorMessage() {
        return validation.getErrorMessage();
    }
}

=========================

==========================
{src/controller/action/BaseSetAction.java}
package controller.action;

/**
 * Representa uma ação base para modelos com um supermodelo adicional.
 *
 * A classe `BaseSetAction` é uma extensão de `BaseAction` e adiciona a capacidade de associar um supermodelo ao modelo principal da ação. Esta classe é útil quando a ação precisa de um contexto adicional ou um modelo de nível superior para operar junto ao modelo principal.
 *
 * As subclasses de `BaseSetAction` devem fornecer a implementação específica de como a ação será executada no modelo principal.
 *
 * @param <T> O tipo de modelo principal sobre o qual a ação será executada.
 * @param <M> O tipo de supermodelo que é associado ao modelo principal.
 */
public abstract class BaseSetAction<T, M> extends BaseAction<T> {

    /**
     * O supermodelo associado ao modelo principal para a execução da ação.
     */
    protected M superModel;

    /**
     * Constrói uma nova instância de `BaseSetAction` com o validador fornecido.
     *
     * @param validation O validador a ser utilizado para validar o modelo principal antes de executar a ação.
     */
    public BaseSetAction(Validation<T> validation) {
        super(validation);
    }

    /**
     * Define o supermodelo que será associado ao modelo principal.
     *
     * @param superModel O supermodelo a ser associado ao modelo principal.
     */
    public void setSuperModel(M superModel) {
        this.superModel = superModel;
    }

}

=========================

==========================
{src/controller/action/Validation.java}
package controller.action;

/**
 * Interface que define a validação de modelos para ações.
 *
 * A interface `Validation` é usada para validar um modelo antes de realizar uma ação sobre ele. A validação permite garantir que o modelo esteja em um estado adequado antes de ser processado, evitando erros ou inconsistências durante a execução da ação.
 *
 * As classes que implementam esta interface devem fornecer a lógica de validação específica para o modelo que estão tratando.
 *
 * @param <T> O tipo de modelo a ser validado.
 */
public interface Validation<T> {

    /**
     * Valida o modelo fornecido.
     *
     * Este método deve ser implementado para verificar se o modelo está em um estado válido para a execução da ação. O que constitui um estado válido depende da implementação concreta da validação.
     *
     * @param model O modelo a ser validado.
     * @return `true` se o modelo for válido, caso contrário `false`.
     */
    boolean isValid(T model);

    /**
     * Retorna a mensagem de erro associada à validação.
     *
     * Se o modelo não for válido, este método deve retornar uma mensagem explicativa do erro. A mensagem pode ser usada para informar o usuário sobre o que está errado com o modelo.
     *
     * @return A mensagem de erro, ou uma string vazia se não houver erro.
     */
    String getErrorMessage();
}

=========================

==========================
{src/controller/action/avaliacao/CreateAvaliacaoAction.java}
package controller.action.avaliacao;

import controller.action.ActionResult;
import controller.action.BaseSetAction;
import controller.action.Validation;
import controller.dataBase.FilmeRepository;
import controller.dataBase.LivroRepository;
import controller.dataBase.SerieRepository;
import model.*;
import model.commons.IAvaliavel;

import java.time.LocalDateTime;

/**
 * Classe responsável por realizar a ação de criação de uma {@link Avaliacao}
 * associada a um objeto que implementa a interface {@link IAvaliavel}.
 * Essa classe herda de {@link BaseSetAction}, permitindo configurar
 * tanto o modelo {@link Avaliacao} quanto o modelo superior (ex: Filme, Livro ou Temporada).
 *
 * <p>Durante a execução da ação, a classe valida o modelo de avaliação,
 * define a data da avaliação como a data/hora atual e atualiza o repositório
 * correspondente com a nova avaliação associada.</p>
 *
 * <p>Suporta os seguintes tipos de mídia:
 * <ul>
 *     <li>{@link TipoMedia#FILME}</li>
 *     <li>{@link TipoMedia#LIVRO}</li>
 *     <li>{@link TipoMedia#TEMPORADA}</li>
 * </ul>
 * </p>
 *
 * @author [Seu Nome]
 */
public class CreateAvaliacaoAction extends BaseSetAction<Avaliacao, IAvaliavel> {

    /**
     * Construtor que recebe uma validação específica para o modelo de avaliação.
     *
     * @param validation Objeto responsável por validar a {@link Avaliacao} antes da execução da ação.
     */
    public CreateAvaliacaoAction(Validation<Avaliacao> validation) {
        super(validation);
    }

    /**
     * Executa o processo de criação de uma avaliação.
     * Valida o modelo, define a data atual como data da avaliação e persiste a avaliação
     * no repositório correspondente ao tipo de mídia ({@link Filme}, {@link Livro} ou {@link Temporada}).
     *
     * @param model Objeto {@link Avaliacao} contendo os dados da avaliação a ser criada.
     * @return {@link ActionResult} representando o sucesso ou falha da operação, juntamente com uma mensagem.
     */
    @Override
    public ActionResult execute(Avaliacao model) {
        // Verifica se o modelo é válido
        if (!isValid(model)) {
            return new ActionResult(false, getErrorMessage());
        }
        
        //Setar a data de avaliação
        LocalDateTime dataAtual = LocalDateTime.now();
        model.setDataAvaliacao(dataAtual);
        
        if (superModel == null) {
            return new ActionResult(false, "Super model is null");
        }
        
        if(superModel.getTipoMedia() == null){
            return new ActionResult(false, "Media type cannot be null");
        } 
        
        if (superModel.getTipoMedia()== TipoMedia.FILME) {
            // Avaliação de filme

            superModel.avaliar(model);
            FilmeRepository filmeRepository = FilmeRepository.getInstance();
            try {
                filmeRepository.update((Filme) superModel);
            }catch (Exception e){
                return new ActionResult(false, e.getMessage());
            }

        } else if (superModel.getTipoMedia() == TipoMedia.LIVRO) {
            // Avaliação de Livro

            superModel.avaliar(model);
            LivroRepository livroRepository = LivroRepository.getInstance();

            try {
                livroRepository.update((Livro) superModel);
            }catch (Exception e) {
                return new ActionResult(false, e.getMessage());
            }


        } else if (superModel.getTipoMedia() == TipoMedia.TEMPORADA) {
            // Avaliação de Temporada

            superModel.avaliar(model);
            Temporada temporada = (Temporada) superModel;
            SerieRepository serieRepository = SerieRepository.getInstance();
            int serieId = temporada.getSerieId();
            Serie serie = serieRepository.getItemById(serieId);

            if (serie == null) {
                return new ActionResult(false, "Serie not found");
            }

            serie.updateTemporadaById(temporada.getId(), temporada);

            try {
                serieRepository.update(serie);
            }
            catch (Exception e) {
                return new ActionResult(false, e.getMessage());
            }

        } else {
            return new ActionResult(false, "Tipo de mídia inválido");
        }
        
        return new ActionResult(true, "Avaliacao criada com sucesso");
    }
}

=========================

==========================
{src/controller/action/avaliacao/CreateAvaliacaoValidation.java}
package controller.action.avaliacao;

import controller.action.Validation;
import model.Avaliacao;

/**
 * Implementação da interface {@link Validation} para validar objetos do tipo {@link Avaliacao}.
 *
 * <p>Esta classe verifica se a pontuação atribuída à avaliação está dentro de um intervalo válido (entre 1 e 5, inclusive).</p>
 *
 * <p>Se a validação falhar, a ação que utiliza esta validação poderá acessar a mensagem de erro por meio do método {@link #getErrorMessage()}.</p>
 *
 * @author [Seu Nome]
 */
public class CreateAvaliacaoValidation implements Validation<Avaliacao> {

    /** Mensagem de erro que descreve a falha de validação, caso ocorra. */
    private String errorMessage;

    /**
     * Verifica se o objeto {@link Avaliacao} é válido.
     *
     * <p>Apenas avaliações com pontuação entre 1 e 5 são consideradas válidas.</p>
     *
     * @param model O objeto {@link Avaliacao} a ser validado.
     * @return {@code true} se a avaliação for válida; {@code false} caso contrário.
     */
    @Override
    public boolean isValid(Avaliacao model) {
        if (model == null) {
            errorMessage = "Avaliacao está nula";
            return false;
        }

        if (model.getPontuacao() < 1 || model.getPontuacao() > 5) {
            errorMessage = "Pontuação inválida: deve estar entre 1 e 5.";
            return false;
        }

        // Adicione outras validações se necessário
        errorMessage = null;
        return true;
    }

    /**
     * Retorna a mensagem de erro associada à última falha de validação.
     *
     * @return Uma string contendo a mensagem de erro, ou {@code null} se não houve erro.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }

}

=========================

==========================
{src/controller/action/filme/CreateFilmeAction.java}
package controller.action.filme;

import controller.dataBase.FilmeRepository;
import controller.action.ActionResult;
import controller.action.BaseAction;
import controller.action.Validation;
import model.Filme;

/**
 * Ação responsável pela criação de um novo filme no sistema.
 *
 * Esta classe estende {@link BaseAction} e implementa a lógica de criação de
 * um filme, validando o modelo e, em seguida, salvando-o no repositório de filmes.
 * Caso o filme seja inválido, a ação retornará uma mensagem de erro.
 *
 * @see BaseAction
 * @see FilmeRepository
 * @see ActionResult
 * @see Validation
 */
public class CreateFilmeAction extends BaseAction<Filme> {

    /**
     * Construtor da classe CreateFilmeAction.
     *
     * Este construtor inicializa a ação com a validação fornecida para
     * o modelo de filme.
     *
     * @param validation A validação a ser aplicada ao modelo de filme antes
     *                   de sua criação.
     */
    public CreateFilmeAction(Validation<Filme> validation) {
        super(validation);
    }

    /**
     * Executa a ação de criação de um filme no sistema.
     *
     * A ação valida o modelo de filme utilizando a validação fornecida. Se o
     * modelo for válido, o filme é salvo no repositório de filmes. Caso contrário,
     * é retornado um resultado de erro com a mensagem de erro apropriada.
     *
     * @param filme O modelo de filme a ser criado.
     * @return Um {@link ActionResult} indicando se a criação do filme foi
     *         bem-sucedida ou não, juntamente com uma mensagem de sucesso ou erro.
     */
    @Override
    public ActionResult execute(Filme filme) {
        // Verifica se o modelo é válido
        if (!isValid(filme)) {
            return new ActionResult(false, getErrorMessage());
        }

        FilmeRepository.getInstance().add(filme);
        return new ActionResult(true,"Filme criado com sucesso");
    }
}

=========================

==========================
{src/controller/action/filme/CreateFilmeValidation.java}
package controller.action.filme;

import controller.dataBase.FilmeRepository;
import controller.action.Validation;
import model.Filme;

/**
 * Validação para a criação de um filme no sistema.
 *
 * Esta classe implementa a interface {@link Validation} para garantir que um
 * filme esteja em conformidade com as regras de validação antes de ser salvo.
 * A validação inclui a verificação do título, dos gêneros associados ao filme
 * e se o filme já existe no repositório.
 *
 * @see Validation
 * @see FilmeRepository
 * @see Filme
 */
public class CreateFilmeValidation implements Validation<Filme> {
    private String errorMessage;

    /**
     * Valida as propriedades de um modelo de filme.
     *
     * As validações incluem:
     * 1. Verificar se o título do filme não está vazio ou nulo.
     * 2. Verificar se pelo menos um gênero foi selecionado para o filme.
     * 3. Verificar se o filme já existe no repositório.
     *
     * Caso alguma dessas condições não seja atendida, uma mensagem de erro será
     * definida e o método retorna {@code false}.
     *
     * @param model O modelo de filme a ser validado.
     * @return {@code true} se o filme for válido, {@code false} caso contrário.
     */
    @Override
    public boolean isValid(Filme model) {
        // Verifica se o título do filme não está vazio ou nulo
        if (model.getTitulo() == null || model.getTitulo().isEmpty()) {
            errorMessage = "Erro! título vazio";
            return false;
        }

        // Verifica se pelo menos um gênero foi selecionado
        if (model.getGeneros().isEmpty()){
            errorMessage = "Erro! Selecione pelo menos um gênero";
            return false;
        }

        // Verifica se o filme já existe no repositório
        FilmeRepository repository = FilmeRepository.getInstance();
        if(repository.getItems().contains(model)){
            errorMessage = "Erro! Filme já existe na base de dados";
            return false;
        }

        return true;
    }

    /**
     * Retorna a mensagem de erro associada à validação.
     *
     * @return A mensagem de erro se a validação falhar, ou {@code null} se não houver erro.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/action/filme/UpdateFilmeAction.java}
package controller.action.filme;

import controller.dataBase.FilmeRepository;
import controller.action.ActionResult;
import controller.action.BaseAction;
import controller.action.Validation;
import model.Filme;

/**
 * Ação responsável pela atualização de um filme no sistema.
 *
 * Esta classe extende {@link BaseAction} e implementa a lógica para atualizar um filme
 * no repositório, validando se a operação de atualização pode ser realizada com base
 * na validação do modelo de filme.
 *
 * @see BaseAction
 * @see Validation
 * @see FilmeRepository
 * @see Filme
 */
public class UpdateFilmeAction extends BaseAction<Filme> {

    /**
     * Construtor para a ação de atualizar um filme.
     *
     * @param validation A validação que será aplicada ao modelo de filme.
     */
    public UpdateFilmeAction(Validation<Filme> validation) {
        super(validation);
    }

    /**
     * Executa a ação de atualização de um filme.
     *
     * O método realiza a verificação de validade do modelo de filme antes de realizar
     * a atualização. Caso o modelo seja válido, o filme será atualizado no repositório.
     * Caso contrário, retorna um resultado de falha com a mensagem de erro correspondente.
     *
     * @param model O modelo de filme a ser atualizado.
     * @return O resultado da ação, indicando se a operação foi bem-sucedida ou não.
     */
    @Override
    public ActionResult execute(Filme model) {
        // Verifica se o modelo de filme é válido antes de prosseguir com a atualização
        if (!isValid(model)) {
            return new ActionResult(false, getErrorMessage());
        }
        try {
            FilmeRepository.getInstance().update(model);
        } catch (Exception e) {
            return new ActionResult(false, "Erro! " + e.getMessage());
        }
        return new ActionResult(true,"Filme atualizado com sucesso");
    }
}

=========================

==========================
{src/controller/action/filme/UpdateFilmeValidation.java}
package controller.action.filme;

import controller.action.Validation;
import model.Filme;

/**
 * Validação para a atualização de um filme no sistema.
 *
 * Esta classe implementa a interface {@link Validation} para validar um modelo de
 * filme antes de realizar sua atualização. Ela garante que o título do filme não
 * seja vazio e que o filme tenha pelo menos um gênero associado.
 *
 * @see Validation
 * @see Filme
 */
public class UpdateFilmeValidation implements Validation<Filme> {
    private String errorMessage;

    /**
     * Valida as informações do filme para garantir que o título e os gêneros estejam
     * corretamente definidos antes da atualização.
     *
     * A validação verifica que o título do filme não é nulo nem vazio e que pelo
     * menos um gênero foi selecionado para o filme. Se algum desses requisitos
     * não for atendido, o erro correspondente é gerado.
     *
     * @param model O modelo de filme a ser validado.
     * @return {@code true} se o filme for válido para atualização, {@code false}
     *         caso contrário.
     */
    @Override
    public boolean isValid(Filme model) {
        // Verifica se o título do filme é válido (não nulo e não vazio)
        if (model.getTitulo() == null || model.getTitulo().isEmpty()) {
            errorMessage = "Erro! título vazio";
            return false;
        }

        // Verifica se o filme possui pelo menos um gênero
        if (model.getGeneros().isEmpty()) {
            errorMessage = "Erro! Selecione pelo menos um gênero";
            return false;
        }

        return true;
    }

    /**
     * Retorna a mensagem de erro gerada durante a validação.
     *
     * @return A mensagem de erro caso a validação falhe, ou {@code null} se a validação
     *         for bem-sucedida.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/action/genero/CreateGeneroAction.java}
package controller.action.genero;

import controller.dataBase.GeneroRepository;
import controller.action.ActionResult;
import controller.action.BaseAction;
import controller.action.Validation;
import model.Genero;

public class CreateGeneroAction extends BaseAction<Genero> {

    /**
     * Construtor que recebe a validação do modelo {@link Genero}.
     *
     * @param validation A validação do modelo {@link Genero}.
     */
    public CreateGeneroAction(Validation<Genero> validation) {
        super(validation);
    }

    /**
     * Executa a criação de um novo gênero no sistema.
     *
     * A operação primeiro valida o modelo de gênero. Se o modelo for válido,
     * o gênero é salvo no repositório. Caso contrário, retorna um resultado de
     * erro com a mensagem de erro da validação.
     *
     * @param model O modelo {@link Genero} a ser criado.
     * @return Um objeto {@link ActionResult} indicando o sucesso ou falha da operação.
     */
    @Override
    public ActionResult execute(Genero model) {
        // Valida o modelo antes de salvar
        if (!isValid(model)) {
            return new ActionResult(false, getErrorMessage());
        }

        GeneroRepository.getInstance().add(model);
        return new ActionResult(true, "Gênero criado com sucesso");
    }
}

=========================

==========================
{src/controller/action/genero/CreateGeneroValidation.java}
package controller.action.genero;

import controller.dataBase.GeneroRepository;
import controller.action.Validation;
import model.Genero;

/**
 * Validação para a criação de um novo gênero no sistema.
 *
 * Esta classe implementa a interface {@link Validation} e realiza a validação
 * de um modelo {@link Genero} para garantir que ele atenda aos requisitos antes
 * de ser persistido. A validação inclui checagens para garantir que o nome do
 * gênero não seja vazio, tenha um comprimento adequado e que o gênero não exista
 * previamente na base de dados.
 *
 * @see Validation
 * @see Genero
 */
public class CreateGeneroValidation implements Validation<Genero> {
    private String errorMessage;

    /**
     * Valida o modelo de gênero.
     *
     * A validação verifica os seguintes critérios:
     * 1. O nome do gênero não pode ser vazio.
     * 2. O nome do gênero não pode ter mais de 50 caracteres.
     * 3. O nome do gênero deve ter pelo menos 3 caracteres.
     * 4. O gênero não pode existir na base de dados.
     *
     * Caso algum critério falhe, é armazenada uma mensagem de erro que pode
     * ser recuperada posteriormente com o método {@link #getErrorMessage}.
     *
     * @param model O modelo {@link Genero} a ser validado.
     * @return {@code true} se o modelo for válido, {@code false} caso contrário.
     */
    @Override
    public boolean isValid(Genero model) {
        // Valida se o nome do gênero está vazio
        if (model.getNome() == null || model.getNome().isEmpty()) {
            errorMessage = "Erro! Nome do gênero não pode ser vazio";
            return false;
        }

        // Valida se o nome do gênero tem mais de 50 caracteres
        if (model.getNome().length() > 50) {
            errorMessage = "Erro! Nome do gênero não pode ter mais de 50 caracteres";
            return false;
        }

        // Valida se o nome do gênero tem pelo menos 3 caracteres
        if (model.getNome().length() < 3) {
            errorMessage = "Erro! Nome do gênero deve ter pelo menos 3 caracteres";
            return false;
        }

        // Valida se o gênero já existe na base de dados
        GeneroRepository repository = GeneroRepository.getInstance();
        if (repository.getItems().stream().anyMatch(g -> g.getNome().equalsIgnoreCase(model.getNome()))) {
            errorMessage = "Erro! Gênero já existe na base de dados";
            return false;
        }

        return true;
    }

    /**
     * Retorna a mensagem de erro que descreve o motivo da falha na validação.
     *
     * @return A mensagem de erro.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/action/livro/CreateLivroAction.java}
package controller.action.livro;

import controller.action.ActionResult;
import controller.action.BaseAction;
import controller.action.Validation;
import controller.dataBase.LivroRepository;
import model.Livro;

/**
 * Ação para criar um novo livro no sistema.
 *
 * Esta classe implementa a ação de criar um novo livro no sistema. Ela valida
 * o modelo de livro antes de persistir no repositório de livros. Se o modelo
 * for válido, o livro é salvo no banco de dados, caso contrário, uma mensagem
 * de erro é retornada.
 *
 * @see BaseAction
 * @see Livro
 * @see LivroRepository
 */
public class CreateLivroAction extends BaseAction<Livro> {

    /**
     * Constrói uma nova ação de criação de livro com a validação fornecida.
     *
     * @param validation A validação a ser utilizada para verificar o modelo de livro.
     */
    public CreateLivroAction(Validation<Livro> validation) {
        super(validation);
    }

    /**
     * Executa a ação de criação de um livro. Valida o modelo e, se válido,
     * persiste o livro no repositório. Caso contrário, retorna uma mensagem de erro.
     *
     * @param livro O modelo {@link Livro} a ser criado.
     * @return O resultado da ação, indicando sucesso ou falha, junto com a mensagem correspondente.
     */
    @Override
    public ActionResult execute(Livro livro) {
        // Verifica se o modelo é válido
        if (!isValid(livro)) {
            return new ActionResult(false, getErrorMessage());
        }

        LivroRepository.getInstance().add(livro);
        return new ActionResult(true,"Livro criado com sucesso");
    }
}

=========================

==========================
{src/controller/action/livro/CreateLivroValidation.java}
package controller.action.livro;

import controller.action.Validation;
import controller.dataBase.LivroRepository;
import model.Livro;

/**
 * Validação para a criação de um novo livro no sistema.
 *
 * Esta classe implementa a interface {@link Validation} e realiza a validação
 * de um modelo de livro antes de sua criação. Ela verifica se o título do livro
 * não está vazio, se o livro possui pelo menos um gênero associado, e se o
 * ISBN do livro não existe previamente na base de dados.
 *
 * @see Validation
 * @see Livro
 * @see LivroRepository
 */
public class CreateLivroValidation implements Validation<Livro> {
    private String errorMessage;

    /**
     * Valida o modelo de livro. Verifica se o título do livro está vazio, se ele
     * possui pelo menos um gênero associado e se o ISBN já existe na base de dados.
     *
     * @param model O modelo {@link Livro} a ser validado.
     * @return {@code true} se o modelo de livro for válido, {@code false} caso contrário.
     */
    @Override
    public boolean isValid(Livro model) {
        // Verifica se o título do livro não está vazio
        if (model.getTitulo() == null || model.getTitulo().isEmpty()) {
            errorMessage = "Erro! titulo vazio";
            return false;
        }

        // Verifica se o livro possui pelo menos um gênero
        if (model.getGeneros().isEmpty()) {
            errorMessage = "Erro! Selecione pelo menos um genero";
            return false;
        }

        // Verifica se o ISBN já existe na base de dados
        LivroRepository repository = LivroRepository.getInstance();
        for (Livro l : repository.getItems()) {
            if (l.getIsbn().equals(model.getIsbn())) {
                errorMessage = "Erro! Já existe um livro com este ISBN na base de dados";
                return false;
            }
        }

        return true;
    }

    /**
     * Retorna a mensagem de erro associada à falha de validação, caso haja.
     *
     * @return A mensagem de erro, ou {@code null} se não houver erro.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/action/livro/UpdateLivroAction.java}
package controller.action.livro;

import controller.action.ActionResult;
import controller.action.BaseAction;
import controller.action.Validation;
import controller.dataBase.LivroRepository;
import model.Livro;

/**
 * Ação para atualizar um livro no sistema.
 *
 * Esta classe representa a ação que realiza a atualização de um livro no repositório
 * de livros. A validação do livro é realizada antes da atualização. Se o livro for válido,
 * ele será atualizado no repositório de livros.
 *
 * @see BaseAction
 * @see Validation
 * @see Livro
 * @see LivroRepository
 */
public class UpdateLivroAction extends BaseAction<Livro> {

    /**
     * Constrói uma instância de {@link UpdateLivroAction} com a validação fornecida.
     *
     * @param validation A validação a ser aplicada ao livro antes da atualização.
     */
    public UpdateLivroAction(Validation<Livro> validation) {
        super(validation);
    }

    /**
     * Executa a ação de atualização de um livro.
     *
     * Este método valida o livro com a validação fornecida. Se o livro for válido, ele
     * será atualizado no repositório de livros. Caso contrário, um erro será retornado
     * com a respectiva mensagem de falha na validação.
     *
     * @param model O modelo {@link Livro} a ser atualizado.
     * @return Um {@link ActionResult} indicando se a operação foi bem-sucedida ou falhou.
     */
    @Override
    public ActionResult execute(Livro model) {
        // Verifica se o modelo é válido antes de proceder
        if (!isValid(model)) {
            return new ActionResult(false, getErrorMessage());
        }
        try {
            LivroRepository.getInstance().update(model);
        } catch (Exception e) {
            return new ActionResult(false, "Erro! " + e.getMessage());
        }
        return new ActionResult(true, "Livro atualizado com sucesso");
    }
}


=========================

==========================
{src/controller/action/livro/UpdateLivroValidation.java}
package controller.action.livro;

import controller.action.Validation;
import model.Livro;

/**
 * Validação para a atualização de um livro no sistema.
 *
 * Esta classe implementa a interface {@link Validation} para validar as informações
 * de um livro antes de sua atualização. Ela verifica se o título do livro não está vazio
 * e se ao menos um gênero foi selecionado.
 *
 * @see Validation
 * @see Livro
 */
public class UpdateLivroValidation implements Validation<Livro> {
    private String errorMessage;

    /**
     * Valida as informações de um livro para garantir que sejam corretas antes da atualização.
     *
     * A validação garante que:
     * 1. O título do livro não pode ser nulo ou vazio.
     * 2. O livro deve ter pelo menos um gênero selecionado.
     *
     * @param model O modelo {@link Livro} a ser validado.
     * @return {@code true} se o livro for válido para atualização, {@code false} caso contrário.
     */
    @Override
    public boolean isValid(Livro model) {
        // Verifica se o título do livro não está vazio ou nulo
        if (model.getTitulo() == null || model.getTitulo().isEmpty()) {
            errorMessage = "Erro! titulo vazio";
            return false;
        }

        // Verifica se o livro possui ao menos um gênero
        if (model.getGeneros().isEmpty()){
            errorMessage = "Erro! Selecione pelo menos um genero";
            return false;
        }

        // Se as condições forem atendidas, o livro é considerado válido
        return true;
    }

    /**
     * Retorna a mensagem de erro gerada durante a validação do livro.
     *
     * @return A mensagem de erro caso a validação falhe, ou {@code null} se não houver erro.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/action/serie/CreateSerieAction.java}
package controller.action.serie;

import controller.dataBase.SerieRepository;
import controller.action.ActionResult;
import controller.action.BaseAction;
import controller.action.Validation;
import model.Serie;

/**
 * Ação para criar uma nova série no sistema.
 *
 * Esta classe é responsável por receber as informações de uma série, validá-las
 * e, caso válidas, salvar a série no repositório. Ela estende a classe {@link BaseAction}
 * e implementa a lógica necessária para criar uma nova série.
 *
 * @see Validation
 * @see Serie
 * @see SerieRepository
 */
public class CreateSerieAction extends BaseAction<Serie> {

    /**
     * Construtor da classe {@link CreateSerieAction}.
     *
     * Inicializa a ação de criação de série com a validação fornecida.
     *
     * @param validation A validação que será aplicada à série antes de ser criada.
     */
    public CreateSerieAction(Validation<Serie> validation) {
        super(validation);
    }

    /**
     * Executa a ação de criação de uma nova série.
     *
     * Este método verifica a validade do modelo de série fornecido. Se o modelo for válido,
     * a série é salva no repositório de séries. Caso contrário, retorna um resultado de falha com a
     * mensagem de erro apropriada.
     *
     * @param serie O objeto {@link Serie} a ser criado.
     * @return O resultado da ação, que contém o status da operação e a mensagem associada.
     */
    @Override
    public ActionResult execute(Serie serie) {
        // Verifica se a série é válida antes de salvar
        if (!isValid(serie)) {
            return new ActionResult(false, getErrorMessage());
        }

        SerieRepository.getInstance().add(serie);
        return new ActionResult(true, "Série criada com sucesso");
    }
}

=========================

==========================
{src/controller/action/serie/CreateSerieValidation.java}
package controller.action.serie;

import controller.action.Validation;
import controller.dataBase.SerieRepository;
import model.Serie;

/**
 * Validação para criação de uma nova série no sistema.
 *
 * Esta classe é responsável por validar as informações de uma série antes de ser criada.
 * Ela verifica se os campos obrigatórios estão preenchidos e se a série não existe
 * já na base de dados. Caso a série não seja válida, retorna uma mensagem de erro apropriada.
 *
 * @see Validation
 * @see Serie
 * @see SerieRepository
 */
public class CreateSerieValidation implements Validation<Serie> {

    private String errorMessage;

    /**
     * Verifica a validade do modelo de série fornecido.
     *
     * Esta validação inclui a verificação se o título da série não é vazio, se pelo menos
     * um gênero foi selecionado e se a série não existe previamente no repositório de séries.
     *
     * @param model O objeto {@link Serie} a ser validado.
     * @return {@code true} se a série for válida, {@code false} caso contrário.
     */
    @Override
    public boolean isValid(Serie model) {
        // Verifica se o título da série está vazio
        if (model.getTitulo() == null || model.getTitulo().isEmpty()) {
            errorMessage = "Erro! titulo vazio";
            return false;
        }

        // Verifica se a série possui pelo menos um gênero
        if (model.getGeneros().isEmpty()) {
            errorMessage = "Erro! Selecione pelo menos um genero";
            return false;
        }

        // Verifica se a série já existe na base de dados
        SerieRepository repository = SerieRepository.getInstance();
        if (repository.getItems().contains(model)) {
            errorMessage = "Erro! Serie ja existe na base de dados";
            return false;
        }

        if(repository.getItems().stream().anyMatch(serie -> serie.getTitulo().equals(model.getTitulo()))){
            errorMessage = "Erro! Serie ja existe na base de dados";
            return false;
        }

        return true;
    }

    /**
     * Retorna a mensagem de erro associada à validação.
     *
     * Caso a série não seja válida, esta mensagem descreve o motivo do erro.
     *
     * @return A mensagem de erro, caso existam falhas na validação.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/action/serie/UpdateSerieAction.java}
package controller.action.serie;

import controller.action.ActionResult;
import controller.action.BaseAction;
import controller.action.Validation;
import controller.dataBase.SerieRepository;
import model.Serie;

/**
 * Ação responsável pela atualização de uma série existente no sistema.
 *
 * Esta classe executa a lógica de atualização de uma série. Ela valida os dados fornecidos para a série
 * antes de proceder com a atualização no repositório de séries. Caso a validação falhe, a ação retorna um
 * resultado de falha com a respectiva mensagem de erro. Caso contrário, a série é atualizada com sucesso.
 *
 * @see ActionResult
 * @see Validation
 * @see Serie
 * @see SerieRepository
 */
public class UpdateSerieAction extends BaseAction<Serie> {

    /**
     * Construtor da ação de atualização de série.
     *
     * @param validation O objeto {@link Validation} usado para validar a série antes da atualização.
     */
    public UpdateSerieAction(Validation<Serie> validation) {
        super(validation);
    }

    /**
     * Executa a ação de atualização da série.
     *
     * Este método valida os dados fornecidos, e caso os dados estejam válidos, atualiza a série no repositório.
     * Se a validação falhar, a ação retorna um resultado indicando o erro. Se a atualização for bem-sucedida,
     * um resultado indicando sucesso é retornado.
     *
     * @param model A série a ser atualizada.
     * @return O resultado da ação, incluindo o status de sucesso ou falha e a mensagem associada.
     */
    @Override
    public ActionResult execute(Serie model) {
        // Verifica se os dados fornecidos são válidos
        if (!isValid(model)) {
            return new ActionResult(false, getErrorMessage());
        }
        try{
            SerieRepository.getInstance().update(model);
        } catch (Exception e) {
            return new ActionResult(false, "Erro! " + e.getMessage());
        }

        return new ActionResult(true, "Serie atualizado com sucesso");
    }
}

=========================

==========================
{src/controller/action/serie/UpdateSerieValidation.java}
package controller.action.serie;

import controller.action.Validation;
import model.Serie;

/**
 * Validação para a atualização de uma série no sistema.
 *
 * Esta classe realiza a validação dos dados fornecidos para uma série antes de permitir sua atualização.
 * A validação assegura que o título da série não esteja vazio e que pelo menos um gênero esteja selecionado.
 * Caso qualquer uma dessas condições falhe, a validação retornará uma mensagem de erro apropriada.
 *
 * @see Validation
 * @see Serie
 */
public class UpdateSerieValidation implements Validation<Serie> {
    private String errorMessage;

    /**
     * Valida os dados fornecidos para a série antes da atualização.
     *
     * A validação garante que o título da série não esteja vazio e que ao menos um gênero seja selecionado.
     * Se alguma dessas condições falhar, a validação retornará uma mensagem de erro específica.
     *
     * @param model A série a ser validada.
     * @return `true` se a série for válida, `false` caso contrário.
     */
    @Override
    public boolean isValid(Serie model) {
        if (model.getTitulo() == null || model.getTitulo().isEmpty()) {
            errorMessage = "Erro! título vazio";
            return false;
        }

        if (model.getGeneros().isEmpty()) {
            errorMessage = "Erro! Selecione pelo menos um gênero";
            return false;
        }

        return true;
    }

    /**
     * Retorna a mensagem de erro associada à validação.
     *
     * Esta mensagem será retornada se a validação falhar, e indica o motivo do erro na série fornecida.
     *
     * @return A mensagem de erro.
     */
    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/action/temporada/CreateTemporadaAction.java}
package controller.action.temporada;

import controller.action.BaseSetAction;
import controller.dataBase.SerieRepository;
import controller.action.ActionResult;
import controller.action.Validation;
import model.Temporada;
import model.Serie;

public class CreateTemporadaAction extends BaseSetAction<Temporada, Serie> {

    public CreateTemporadaAction(Validation<Temporada> validation) {
        super(validation);
    }

    @Override
    public ActionResult execute(Temporada model) {
        if (superModel == null){
            return new ActionResult(false, "Set super model");
        }

        if (!isValid(model)) {
            return new ActionResult(false, getErrorMessage());
        }

        SerieRepository repository= SerieRepository.getInstance();
        superModel.addTemporada(model);
        repository.update(superModel);

        return new ActionResult(true, "Temporada created successfully");
    }
}

=========================

==========================
{src/controller/action/temporada/CreateTemporadaValidation.java}
package controller.action.temporada;

import controller.action.Validation;
import model.Temporada;

public class CreateTemporadaValidation implements Validation<Temporada> {
    String errorMessage;

    @Override
    public boolean isValid(Temporada model) {
        return true;
    }

    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}

=========================

==========================
{src/controller/dataBase/FilmeRepository.java}
package controller.dataBase;

import model.Filme;
import java.util.ArrayList;
import java.util.List;

/**
 * Repositório responsável por gerenciar instâncias da classe {@link Filme}.
 *
 * Implementa a interface {@link IRepository} para fornecer operações básicas de persistência em memória,
 * como salvar, buscar, atualizar e deletar objetos do tipo {@link Filme}.
 *
 * Esta implementação utiliza o padrão Singleton, garantindo que exista apenas uma instância da classe em tempo de execução.
 */
public class FilmeRepository implements IRepository<Filme> {
    private static FilmeRepository instance;
    private List<Filme> filmes;
    private int filmeId;

    /**
     * Construtor privado para garantir o padrão Singleton.
     * Inicializa a lista de filmes e o contador de IDs.
     */
    private FilmeRepository() {
        filmes = new ArrayList<>();
        filmeId = 0;
    }

    /**
     * Retorna a instância única da classe {@code FilmeRepository}.
     *
     * @return Instância única do repositório de filmes.
     */
    public static FilmeRepository getInstance() {
        if (instance == null) {
            instance = new FilmeRepository();
        }
        return instance;
    }

    /**
     * Retorna todos os filmes armazenados no repositório.
     *
     * @return Lista de filmes.
     */
    @Override
    public List<Filme> getItems() {
        return filmes;
    }

    /**
     * Retorna um filme com base no seu ID.
     *
     * @param id ID do filme desejado.
     * @return Filme com o ID correspondente ou {@code null} se não encontrado.
     */
    @Override
    public Filme getItemById(int id) {
        // Busca o filme pelo ID
        for (Filme filme : filmes) {
            if (filme.getId() == id) {
                return filme;
            }
        }
        return null; // Caso não encontre o filme
    }

    /**
     * Atualiza as informações de um filme existente.
     *
     * @param item Filme atualizado que substituirá o anterior.
     */
    @Override
    public void update(Filme item) throws RuntimeException {
        for (int i = 0; i < filmes.size(); i++) {
            if (filmes.get(i).getId() == item.getId()) {
                filmes.set(i, item);
                return;
            }
        }
        throw new RuntimeException("Filme não encontrado para atualização");
    }

    /**
     * Salva um novo filme no repositório e atribui um ID único a ele.
     *
     * @param filme Filme a ser salvo.
     */
    @Override
    public void add(Filme filme) {
        filme.setId(filmeId++);  // Atribui um ID único ao filme antes de salvar
        filmes.add(filme);
    }

    /**
     * Remove um filme do repositório com base no seu ID.
     *
     * @param filme Filme a ser removido.
     */
    @Override
    public void delete(Filme filme) {
        filmes.removeIf(filmeItem -> filmeItem.getId() == filme.getId());
    }

    public void setFilmeId(int id) {
        this.filmeId = id;
    }
}

=========================

==========================
{src/controller/dataBase/GeneroRepository.java}
package controller.dataBase;

import model.Genero;
import java.util.ArrayList;
import java.util.List;

/**
 * {@code GeneroRepository} é uma implementação do padrão de repositório para a entidade {@link Genero}.
 * <p>
 * Fornece métodos para persistência em memória, incluindo operações de criação, leitura, atualização e remoção (CRUD).
 * Implementa a interface {@link IRepository}.
 * <p>
 * Utiliza o padrão Singleton para garantir uma única instância durante a execução da aplicação.
 */
public class GeneroRepository implements IRepository<Genero> {
    private static GeneroRepository instance;
    private List<Genero> generos;
    private int generoId;

    /**
     * Construtor privado. Inicializa a lista de gêneros e o contador de IDs.
     */
    private GeneroRepository() {
        generos = new ArrayList<>();
        generoId = 0;
    }

    /**
     * Retorna a instância única de {@code GeneroRepository}.
     *
     * @return instância única do repositório.
     */
    public static GeneroRepository getInstance() {
        if (instance == null) {
            instance = new GeneroRepository();
        }
        return instance;
    }

    /**
     * Retorna a lista de todos os gêneros armazenados.
     *
     * @return lista de {@link Genero}.
     */
    @Override
    public List<Genero> getItems() {
        return generos;
    }

    /**
     * Retorna o gênero com o ID especificado.
     *
     * @param id o ID do gênero.
     * @return {@link Genero} correspondente ou {@code null} se não for encontrado.
     */
    @Override
    public Genero getItemById(int id) {
        // Busca o gênero pelo ID
        for (Genero genero : generos) {
            if (genero.getId() == id) {
                return genero;
            }
        }
        return null; // Caso não encontre o gênero
    }

    /**
     * Atualiza um gênero existente na lista. Caso não encontre o ID, exibe uma mensagem no console.
     *
     * @param item gênero com os novos dados.
     */
    @Override
    public void update(Genero item) {
        for (int i = 0; i < generos.size(); i++) {
            if (generos.get(i).getId() == item.getId()) {
                generos.set(i, item);
                return;
            }
        }
        throw new RuntimeException("Genero não encontrado para atualização");
    }

    /**
     * Salva um novo gênero atribuindo-lhe um ID único.
     *
     * @param genero o novo gênero a ser salvo.
     */
    @Override
    public void add(Genero genero) {
        genero.setId(generoId++);  // Atribui um ID único ao gênero antes de salvar
        generos.add(genero);
    }

    /**
     * Remove um gênero da lista com base no seu ID.
     *
     * @param genero o gênero a ser removido.
     */
    @Override
    public void delete(Genero genero) {
        generos.removeIf(generoItem -> generoItem.getId() == genero.getId());
    }

    public void setGeneroId(int id) {
        this.generoId = id;
    }
}

=========================

==========================
{src/controller/dataBase/IRepository.java}
package controller.dataBase;

import java.util.List;

/**
 * {@code IRepository} define um contrato genérico para operações básicas de persistência (CRUD)
 * sobre qualquer tipo de entidade {@code T}.
 *
 * @param <T> o tipo de entidade que será manipulada pelo repositório.
 */
public interface IRepository<T> {

    /**
     * Retorna todos os itens armazenados no repositório.
     *
     * @return uma lista contendo todos os itens.
     */
    List<T> getItems();

    /**
     * Busca um item pelo seu identificador único.
     *
     * @param id o ID do item.
     * @return o item correspondente, ou {@code null} se não for encontrado.
     */
    T getItemById(int id);

    /**
     * Atualiza os dados de um item existente.
     *
     * @param item o item com os dados atualizados.
     */
    void update(T item);

    /**
     * Adiciona um novo item ao repositório.
     *
     * @param item o novo item a ser adicionado.
     */
    void add(T item);

    /**
     * Remove um item do repositório.
     *
     * @param item o item a ser removido.
     */
    void delete(T item);
}

=========================

==========================
{src/controller/dataBase/LivroRepository.java}
package controller.dataBase;

import model.Livro;
import java.util.ArrayList;
import java.util.List;

/**
 * {@code LivroRepository} é uma classe singleton responsável por gerenciar o armazenamento
 * em memória de objetos do tipo {@link Livro}.
 *
 * Essa classe fornece funcionalidades para adicionar, atualizar, buscar e remover livros,
 * simulando o comportamento de um repositório de dados.
 */
public class LivroRepository implements IRepository<Livro> {

    private static LivroRepository instance;
    private List<Livro> livros;
    private int livroId;

    /**
     * Construtor privado para garantir o padrão Singleton.
     * Inicializa a lista de livros e o contador de IDs.
     */
    private LivroRepository() {
        livros = new ArrayList<>();
        livroId = 0;
    }

    /**
     * Retorna a instância única da classe {@code LivroRepository}.
     *
     * @return instância única de {@code LivroRepository}
     */
    public static LivroRepository getInstance() {
        if (instance == null) {
            instance = new LivroRepository();
        }
        return instance;
    }

    /**
     * Retorna todos os livros armazenados no repositório.
     *
     * @return lista de livros cadastrados
     */
    @Override
    public List<Livro> getItems() {
        return livros;
    }

    /**
     * Retorna um livro com base no ID informado.
     *
     * @param id o identificador do livro
     * @return o livro correspondente ao ID ou {@code null} se não for encontrado
     */
    @Override
    public Livro getItemById(int id) {
        // Busca o livro pelo ID
        for (Livro livro : livros) {
            if (livro.getId() == id) {
                return livro;
            }
        }
        return null;
    }

    /**
     * Atualiza um livro existente no repositório.
     *
     * @param item o livro com os dados atualizados
     * @throws RuntimeException se o livro não for encontrado para atualização
     */
    @Override
    public void update(Livro item) throws RuntimeException {
        for (int i = 0; i < livros.size(); i++) {
            if (livros.get(i).getId() == item.getId()) {
                livros.set(i, item);
                return;
            }
        }
        throw new RuntimeException("Livro não encontrado para atualização.");
    }

    /**
     * Adiciona um novo livro ao repositório, atribuindo-lhe um ID único.
     *
     * @param livro o livro a ser adicionado
     */
    @Override
    public void add(Livro livro) {
        livro.setId(livroId++);
        livros.add(livro);
    }

    /**
     * Remove um livro do repositório com base em seu ID.
     *
     * @param livro o livro a ser removido
     */
    @Override
    public void delete(Livro livro) {
        livros.removeIf(livroItem -> livroItem.getId() == livro.getId());
    }

    public void setLivroId(int id) {
        this.livroId = id;
    }
}

=========================

==========================
{src/controller/dataBase/SerieRepository.java}
package controller.dataBase;

import model.Serie;
import java.util.ArrayList;
import java.util.List;

/**
 * {@code SerieRepository} é uma classe que implementa o padrão Singleton para gerenciar
 * uma coleção de objetos {@link Serie}.
 *
 * Atua como um repositório em memória, oferecendo operações básicas como adicionar,
 * buscar, atualizar e remover séries.
 *
 * Essa implementação não realiza persistência em disco ou banco de dados, sendo ideal
 * para fases iniciais de desenvolvimento e testes.
 */
public class SerieRepository implements IRepository<Serie> {

    private static SerieRepository instance;
    private List<Serie> series;
    private int serieId;

    /**
     * Construtor privado. Garante que a instância seja única (Singleton).
     * Inicializa a lista de séries e o contador de IDs.
     */
    private SerieRepository() {
        series = new ArrayList<>();
        serieId = 0;
    }

    /**
     * Retorna a instância única da classe {@code SerieRepository}.
     *
     * @return instância única de {@code SerieRepository}
     */
    public static SerieRepository getInstance() {
        if (instance == null) {
            instance = new SerieRepository();
        }
        return instance;
    }

    /**
     * Retorna a lista de todas as séries cadastradas no repositório.
     *
     * @return lista de séries
     */
    @Override
    public List<Serie> getItems() {
        return series;
    }

    /**
     * Retorna uma série com base no ID fornecido.
     *
     * @param id o identificador da série
     * @return a série correspondente ou {@code null} se não for encontrada
     */
    @Override
    public Serie getItemById(int id) {
        for (Serie serie : series) {
            if (serie.getId() == id) {
                return serie;
            }
        }
        return null;
    }

    /**
     * Atualiza os dados de uma série já existente no repositório.
     *
     * @param item a série com as informações atualizadas
     * @throws RuntimeException se a série não for encontrada para atualização
     */
    @Override
    public void update(Serie item) {
        for (int i = 0; i < series.size(); i++) {
            if (series.get(i).getId() == item.getId()) {
                series.set(i, item);
                return;
            }
        }
        throw new RuntimeException("Série não encontrada para atualização.");
    }

    /**
     * Adiciona uma nova série ao repositório, atribuindo a ela um ID único.
     *
     * @param serie a série a ser adicionada
     */
    @Override
    public void add(Serie serie) {
        serie.setId(serieId++);
        series.add(serie);
    }

    /**
     * Remove uma série do repositório com base em seu ID.
     *
     * @param serie a série a ser removida
     */
    @Override
    public void delete(Serie serie) {
        series.removeIf(serieItem -> serieItem.getId() == serie.getId());
    }

    public void setSerieId(int id) {
        this.serieId = id;
    }
}

=========================

==========================
{src/controller/filter/Filter.java}
package controller.filter;

import model.Media;

import java.util.List;

/**
 * A classe {@code Filter} serve como base para todos os filtros aplicáveis sobre listas de {@code Media}.
 * Os filtros concretos devem estender esta classe e implementar a lógica no método {@code apply()}.
 */
public abstract class Filter {
    /**
     * Lista de mídias sobre a qual o filtro será aplicado.
     */
    protected List<Media> medias;

    /**
     * Mensagem informativa que pode ser usada para retornar o status ou resultado do filtro.
     * (Ainda não implementado totalmente).
     */
    private String message;

    /**
     * Aplica a lógica do filtro sobre a lista de mídias.
     * Deve ser implementado pelas subclasses.
     */
    abstract void apply();

    /**
     * Retorna a lista de mídias associada a este filtro.
     *
     * @return lista de mídias filtradas ou em processo de filtragem.
     */
    List<Media> getMedias() {
        return medias;
    }

    /**
     * Define a lista de mídias que será usada no filtro.
     *
     * @param medias lista de mídias a ser filtrada.
     */
    void setMedias(List<Media> medias) {
        this.medias = medias;
    }

    /**
     * Retorna a mensagem associada à execução do filtro.
     *
     * @return mensagem de status ou descrição do filtro.
     */
    String getMessage() {
        return message;
    }
}

=========================

==========================
{src/controller/filter/FilterChain.java}
package controller.filter;

import controller.search.SearchResults;
import java.util.ArrayList;
import java.util.List;

/**
 * A classe {@code FilterChain} é responsável por aplicar uma cadeia de filtros
 * sobre uma lista de mídias encapsulada em um objeto {@link SearchResults}.
 *
 * Cada filtro da cadeia realiza uma operação de filtragem específica e modifica
 * a lista de mídias com base em critérios definidos. As mensagens geradas por cada
 * filtro são concatenadas para fornecer feedback ao usuário.
 *
 * Este padrão permite flexibilidade e modularidade ao aplicar múltiplos critérios
 * de filtragem de forma sequencial.
 */
public class FilterChain {
    private List<Filter> filters;
    private SearchResults searchResults;

    /**
     * Construtor padrão. Inicializa a lista de filtros.
     */
    public FilterChain() {
        this.filters = new ArrayList<>();
    }

    /**
     * Adiciona um filtro à cadeia de filtros que serão aplicados.
     *
     * @param filter o filtro a ser adicionado
     */
    public void addFilter(Filter filter) {
        filters.add(filter);
    }

    /**
     * Aplica todos os filtros da cadeia sobre os resultados de busca atuais.
     *
     * Cada filtro opera sobre a lista atual de mídias e a atualiza no {@link SearchResults}.
     * As mensagens geradas pelos filtros são concatenadas ao final de cada aplicação.
     */
    public void applyFilters() {
        for (Filter filter : filters) {
            filter.setMedias(searchResults.getMediaList());
            filter.apply();
            searchResults.setMediaList(filter.getMedias());
            searchResults.setMessage(searchResults.getMessage() + "\n" + filter.getMessage());
        }
    }

    /**
     * Verifica se a cadeia de filtros está vazia.
     *
     * @return {@code true} se não há filtros, {@code false} caso contrário
     */
    public boolean isEmpty() {
        return filters.isEmpty();
    }

    /**
     * Define o objeto {@link SearchResults} que será usado como base
     * para os filtros aplicados.
     *
     * @param searchResults os resultados de busca iniciais
     */
    public void setSearchResults(SearchResults searchResults) {
        this.searchResults = searchResults;
    }

    /**
     * Retorna o objeto {@link SearchResults} com os resultados após os filtros.
     *
     * @return os resultados de busca processados
     */
    public SearchResults getSearchResults() {
        return searchResults;
    }
}

=========================

==========================
{src/controller/filter/GenreFilter.java}
package controller.filter;

import model.Genero;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * A classe {@code GenreFilter} é responsável por filtrar mídias com base
 * nos gêneros associados a elas.
 *
 * Este filtro pode operar de duas formas distintas, definidas pela enumeração
 * {@link GenreFilterType}:
 * <ul>
 *     <li>{@code CONTEM}: mantém apenas as mídias que contêm todos os gêneros informados</li>
 *     <li>{@code NAO_CONTEM}: mantém apenas as mídias que não contêm todos os gêneros informados</li>
 * </ul>
 *
 * Esta classe estende {@link Filter}, utilizando sua lista de mídias para aplicar
 * a lógica de filtragem apropriada.
 */
public class GenreFilter extends Filter {

    private final List<Genero> filterValue;
    private final GenreFilterType filterType;

    /**
     * Construtor da classe {@code GenreFilter}.
     *
     * @param filterType   o tipo de filtragem a ser aplicado (CONTEM ou NAO_CONTEM)
     * @param filterValue  a lista de gêneros a ser usada como critério de filtragem
     */
    public GenreFilter(GenreFilterType filterType, List<Genero> filterValue) {
        super();
        this.filterValue = filterValue;
        this.filterType = filterType;
    }

    /**
     * Aplica o filtro de gênero à lista de mídias.
     *
     * Dependendo do tipo de filtro, a lista será reduzida apenas às mídias
     * que contêm ou que não contêm todos os gêneros especificados.
     */
    @Override
    void apply() {
        switch (filterType) {
            case CONTEM:
                medias = medias.stream()
                        .filter(media -> media.getGeneros().containsAll(filterValue))
                        .collect(Collectors.toList());
                break;
            case NAO_CONTEM:
                medias = medias.stream()
                        .filter(media -> !media.getGeneros().containsAll(filterValue))
                        .collect(Collectors.toList());
                break;
        }
    }
}

=========================

==========================
{src/controller/filter/GenreFilterType.java}
package controller.filter;

/**
 * Enumeração que define os tipos de filtro de gênero para a busca de mídias.
 * Cada tipo de filtro tem uma descrição que explica o comportamento do filtro.
 */
public enum GenreFilterType {
    /**
     * Filtro que retorna os resultados que contêm os gêneros especificados.
     */
    CONTEM("Contém os gêneros"),

    /**
     * Filtro que retorna os resultados que não contêm os gêneros especificados.
     */
    NAO_CONTEM("Não contém os gêneros");

    private String descricao;

    /**
     * Construtor que define a descrição associada ao tipo de filtro.
     *
     * @param descricao Descrição do tipo de filtro.
     */
    GenreFilterType(String descricao) {
        this.descricao = descricao;
    }

    /**
     * Retorna a descrição do tipo de filtro.
     *
     * @return Descrição do filtro.
     */
    public String getDescricao() {
        return descricao;
    }
}

=========================

==========================
{src/controller/filter/YearFilter.java}
package controller.filter;

import java.util.List;
import java.util.stream.Collectors;

/**
 * A classe {@code YearFilter} é responsável por filtrar mídias com base no ano
 * de lançamento.
 *
 * O filtro pode ser configurado para aplicar diferentes condições em relação ao
 * ano de lançamento das mídias, de acordo com o tipo de filtro especificado na
 * enumeração {@link YearFilterType}.
 *
 * Os tipos de filtro disponíveis são:
 * <ul>
 *     <li>{@code MAIOR}: mantém as mídias cujo ano de lançamento é maior que o valor fornecido</li>
 *     <li>{@code MENOR}: mantém as mídias cujo ano de lançamento é menor que o valor fornecido</li>
 *     <li>{@code IGUAL}: mantém as mídias cujo ano de lançamento é igual ao valor fornecido</li>
 *     <li>{@code DIFERENTE}: mantém as mídias cujo ano de lançamento é diferente do valor fornecido</li>
 * </ul>
 *
 * Esta classe estende {@link Filter}, utilizando a lista de mídias para aplicar
 * o filtro de acordo com a condição fornecida.
 */
public class YearFilter extends Filter {

    private YearFilterType filterType;
    private int filterValue;

    /**
     * Construtor da classe {@code YearFilter}.
     *
     * @param filterType  o tipo de filtragem a ser aplicado (MAIOR, MENOR, IGUAL ou DIFERENTE)
     * @param filterValue o ano de referência para o filtro
     */
    public YearFilter(YearFilterType filterType, int filterValue) {
        super();
        this.filterType = filterType;
        this.filterValue = filterValue;
    }

    /**
     * Aplica o filtro de ano à lista de mídias.
     *
     * Dependendo do tipo de filtro, a lista será reduzida apenas às mídias
     * cujo ano de lançamento atenda à condição especificada:
     * <ul>
     *     <li>MAIOR: ano de lançamento maior que o valor fornecido</li>
     *     <li>MENOR: ano de lançamento menor que o valor fornecido</li>
     *     <li>IGUAL: ano de lançamento igual ao valor fornecido</li>
     *     <li>DIFERENTE: ano de lançamento diferente do valor fornecido</li>
     * </ul>
     */
    @Override
    void apply() {
        if (filterType == YearFilterType.MAIOR) {
            medias = medias.stream()
                    .filter(media -> media.getDataLancamento().getYear() > filterValue)
                    .collect(Collectors.toList());
        } else if (filterType == YearFilterType.MENOR) {
            medias = medias.stream()
                    .filter(media -> media.getDataLancamento().getYear() < filterValue)
                    .collect(Collectors.toList());
        } else if (filterType == YearFilterType.IGUAL) {
            medias = medias.stream()
                    .filter(media -> media.getDataLancamento().getYear() == filterValue)
                    .collect(Collectors.toList());
        } else if (filterType == YearFilterType.DIFERENTE) {
            medias = medias.stream()
                    .filter(media -> media.getDataLancamento().getYear() != filterValue)
                    .collect(Collectors.toList());
        } else {
            System.out.println("Tipo de filtro inválido para YearFilter");
        }
    }
}

=========================

==========================
{src/controller/filter/YearFilterType.java}
package controller.filter;

/**
 * A enumeração {@code YearFilterType} define os tipos de filtro que podem ser aplicados
 * para comparar o ano de lançamento das mídias.
 *
 * Cada valor da enumeração representa um tipo de condição que pode ser usada para filtrar as mídias
 * com base no ano de lançamento:
 * <ul>
 *     <li>{@code MAIOR}: Filtra as mídias cujo ano de lançamento é maior que o valor fornecido.</li>
 *     <li>{@code MENOR}: Filtra as mídias cujo ano de lançamento é menor que o valor fornecido.</li>
 *     <li>{@code IGUAL}: Filtra as mídias cujo ano de lançamento é igual ao valor fornecido.</li>
 *     <li>{@code DIFERENTE}: Filtra as mídias cujo ano de lançamento é diferente do valor fornecido.</li>
 * </ul>
 */
public enum YearFilterType {

    MAIOR("Data maior que"),
    MENOR("Data menor que"),
    IGUAL("Data Igual a"),
    DIFERENTE("Data Diferente de");

    private String descricao;

    /**
     * Construtor da enumeração {@code YearFilterType}.
     *
     * @param descricao a descrição do tipo de filtro
     */
    YearFilterType(String descricao){
        this.descricao = descricao;
    }

    /**
     * Obtém a descrição associada ao tipo de filtro.
     *
     * @return a descrição do tipo de filtro
     */
    public String getDescricao(){
        return descricao;
    }
}

=========================

==========================
{src/controller/search/Search.java}
package controller.search;

/**
 * Interface que define uma operação de busca em um repositório de mídias.
 *
 * Implementações dessa interface devem executar a lógica de pesquisa usando
 * um termo de busca e retornar um objeto {@link SearchResults} contendo os
 * resultados encontrados e eventuais mensagens de status.
 *
 * @see SearchResults
 */
public interface Search {

    /**
     * Executa a pesquisa com base no termo fornecido.
     *
     * @param searchTerm O termo de busca (por exemplo, título, gênero, autor, etc.).
     * @return Um {@link SearchResults} contendo a lista de itens encontrados
     *         e mensagens de feedback sobre a busca.
     */
    SearchResults execute(String searchTerm);
}

=========================

==========================
{src/controller/search/SearchAll.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Media;

import java.util.ArrayList;
import java.util.List;

/**
 * Implementação de {@link Search} que retorna todas as mídias armazenadas em um repositório.
 * <p>
 * Este buscador simplesmente obtém todos os itens de mídia disponíveis no
 * repositório configurado e retorna um {@link SearchResults} contendo a lista
 * de mídias e uma mensagem de status.
 * </p>
 *
 * @see Search
 * @see IRepository
 * @see SearchResults
 */
public class SearchAll implements Search {

    /**
     * Repositório de onde serão obtidas todas as mídias.
     */
    private IRepository repository;

    /**
     * Executa a busca retornando todas as mídias do repositório.
     *
     * @param searchTerm Termo de busca (é ignorado nesta implementação, pois
     *                   sempre retornamos todas as mídias).
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *           <li>Lista de todas as mídias obtidas do repositório;</li>
     *           <li>Mensagem indicando o resultado da operação.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        List<Media> medias = new ArrayList<>(repository.getItems());

        String message = medias.isEmpty()
                ? "Mídias não encontradas"
                : "Busca: todas as mídias";

        return new SearchResults(medias, message);
    }

    /**
     * Define o repositório de onde as mídias serão obtidas.
     *
     * @param repository Repositório de mídias (por exemplo, {@link controller.dataBase.FilmeRepository},
     *                   {@link controller.dataBase.LivroRepository} ou {@link controller.dataBase.SerieRepository}).
     */
    public void setRepository(IRepository repository) {
        this.repository = repository;
    }
}

=========================

==========================
{src/controller/search/SearchAutor.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Livro;
import model.Media;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementação de {@link Search} que realiza buscas de livros pelo nome do autor.
 * <p>
 * Executa a pesquisa sobre o repositório de {@link Livro}, filtrando aqueles
 * cujo autor contém o termo de busca (case-insensitive), e retorna os resultados
 * como uma lista de {@link Media}.
 * </p>
 *
 * @see Search
 * @see SearchResults
 * @see IRepository
 * @see Livro
 */
public class SearchAutor implements Search {

    /**
     * Repositório de livros a ser utilizado na pesquisa.
     */
    private IRepository<Livro> livroRepository;

    /**
     * Executa a busca de livros cujo autor contém o termo fornecido.
     *
     * @param searchTerm Termo de busca para o nome do autor.
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *           <li>Lista de mídias (livros) cujo autor corresponde ao termo;</li>
     *           <li>Mensagem de status sobre o resultado da busca.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        List<Media> medias = livroRepository.getItems().stream()
                .filter(livro -> livro.getAutor()
                        .toLowerCase()
                        .contains(searchTerm.toLowerCase()))
                .collect(Collectors.toList());

        String message = medias.isEmpty()
                ? "Mídias não encontradas"
                : "Busca por Autor: " + searchTerm;

        return new SearchResults(medias, message);
    }

    /**
     * Define o repositório de livros que será usado nesta busca.
     *
     * @param livroRepository Repositório de {@link Livro}.
     */
    public void setRepository(IRepository<Livro> livroRepository) {
        this.livroRepository = livroRepository;
    }
}

=========================

==========================
{src/controller/search/SearchController.java}
package controller.search;

import controller.filter.FilterChain;
import model.Media;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Controlador abstrato para execução de buscas com suporte a filtros e ordenação.
 * <p>
 * Encapsula o termo de busca e o campo de pesquisa, delega a estratégia de busca à
 * {@link SearchFactory}, aplica filtros encadeados via {@link FilterChain} e
 * realiza ordenação dos resultados com base na pontuação das mídias.
 * </p>
 *
 * @see SearchFactory
 * @see Search
 * @see SearchResults
 * @see FilterChain
 */
public abstract class SearchController {
    private SearchFields searchField;
    private String searchTerm;
    private SearchResults searchResults;
    protected SearchFactory searchFactory;
    private FilterChain filterChain;
    private boolean ordenacao;

    /**
     * Constrói um controlador de busca.
     *
     * @param searchTerm  o termo de busca (por exemplo, título, autor, gênero etc.)
     * @param searchField o campo de pesquisa definido em {@link SearchFields}
     */
    public SearchController(String searchTerm, SearchFields searchField) {
        this.searchTerm = searchTerm;
        this.searchField = searchField;
        this.filterChain = null;
    }

    /**
     * Executa a busca conforme o termo e o campo especificados, aplica filtros e ordena os resultados.
     * <p>
     * O fluxo de execução é:
     * <ol>
     *   <li>Validação de nulo para {@code searchField} e {@code searchTerm};</li>
     *   <li>Criação da estratégia de busca via {@link SearchFactory#createSearch};</li>
     *   <li>Execução da busca e obtenção de {@link SearchResults};</li>
     *   <li>Aplicação de filtros encadeados se presentes;</li>
     *   <li>Ordenação da lista de {@link Media} pela pontuação, crescente ou decrescente;</li>
     *   <li>Atualização dos resultados ordenados em {@code searchResults}.</li>
     * </ol>
     * </p>
     */
    public void execute() {
        if (searchField == null) {
            searchResults = new SearchResults(null, "Error: Campo de pesquisa não pode ser nulo");
            return;
        }
        if (searchTerm == null) {
            searchResults = new SearchResults(null, "Error: Termo de pesquisa não pode ser nulo");
            return;
        }

        Search search = searchFactory.createSearch(searchField);
        searchResults = search.execute(searchTerm);

        if (!searchResults.isEmpty() && filterChain != null && !filterChain.isEmpty()) {
            filterChain.setSearchResults(searchResults);
            filterChain.applyFilters();
            searchResults = filterChain.getSearchResults();
        }

        List<Media> orderedMediaList;
        if (ordenacao) {
            // Ordem decrescente por pontuação
            orderedMediaList = searchResults.getMediaList().stream()
                    .sorted(Comparator.comparing(Media::getPontuacao).reversed())
                    .collect(Collectors.toList());
        } else {
            // Ordem crescente por pontuação
            orderedMediaList = searchResults.getMediaList().stream()
                    .sorted(Comparator.comparing(Media::getPontuacao))
                    .collect(Collectors.toList());
        }

        searchResults.setMediaList(orderedMediaList);
    }

    /**
     * Define a ordem de ordenação dos resultados por pontuação.
     *
     * @param ordem {@code true} para decrescente, {@code false} para crescente
     */
    public void setOrdenacao(boolean ordem) {
        this.ordenacao = ordem;
    }

    /**
     * Retorna os resultados da última busca executada.
     *
     * @return {@link SearchResults} contendo lista de mídias e mensagem de status
     */
    public SearchResults getSearchResults() {
        return searchResults;
    }

    /**
     * Define a cadeia de filtros a ser aplicada aos resultados da busca.
     *
     * @param filterChain objeto {@link FilterChain} contendo filtros a aplicar
     */
    public void setFilterChain(FilterChain filterChain) {
        this.filterChain = filterChain;
    }
}

=========================

==========================
{src/controller/search/SearchDirector.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Filme;
import model.Media;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementação de {@link Search} que realiza buscas de filmes pelo nome do diretor.
 * <p>
 * Executa a pesquisa no repositório de {@link Filme}, filtrando aqueles
 * cujo nome do diretor contém o termo de busca (case-insensitive), e retorna
 * os resultados como uma lista de {@link Media}.
 * </p>
 *
 * @see Search
 * @see SearchResults
 * @see IRepository
 * @see Filme
 */
public class SearchDirector implements Search {

    /**
     * Repositório de filmes usado na pesquisa.
     */
    private IRepository<Filme> filmeRepository;

    /**
     * Executa a busca de filmes cujo diretor contém o termo fornecido.
     *
     * @param searchTerm Termo de busca para o nome do diretor.
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *           <li>Lista de mídias (filmes) cujo diretor corresponde ao termo;</li>
     *           <li>Mensagem de status indicando o resultado da busca.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        List<Media> medias = filmeRepository.getItems().stream()
                .filter(filme -> filme.getDirecao()
                        .toLowerCase()
                        .contains(searchTerm.toLowerCase()))
                .collect(Collectors.toList());

        String message = medias.isEmpty()
                ? "Mídias não encontradas"
                : "Busca por Diretor: " + searchTerm;

        return new SearchResults(medias, message);
    }

    /**
     * Define o repositório de filmes que será usado nesta busca.
     *
     * @param filmeRepository Repositório de {@link Filme}.
     */
    public void setRepository(IRepository<Filme> filmeRepository) {
        this.filmeRepository = filmeRepository;
    }
}

=========================

==========================
{src/controller/search/SearchElenco.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Media;
import model.MediaAudioVisual;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementação de {@link Search} que realiza buscas de mídias audiovisuais
 * pelo nome de um membro do elenco.
 * <p>
 * Executa a pesquisa sobre um repositório de {@link MediaAudioVisual}, filtrando
 * aqueles cujo elenco (lista de {@code String}) contém o termo de busca
 * (case-insensitive), e retorna os resultados como uma lista de {@link Media}.
 * </p>
 *
 * @see Search
 * @see SearchResults
 * @see IRepository
 * @see MediaAudioVisual
 */
public class SearchElenco implements Search {

    /**
     * Repositório de mídias audiovisuais usado na pesquisa.
     */
    private IRepository repository;

    /**
     * Executa a busca de mídias cujo elenco contém o termo fornecido.
     *
     * @param searchTerm Termo de busca para o nome de um membro do elenco.
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *           <li>Lista de mídias cujo elenco corresponde ao termo;</li>
     *           <li>Mensagem de status indicando o resultado da busca.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        List<MediaAudioVisual> medias = new ArrayList<>(repository.getItems());

        List<Media> resultados = medias.stream()
                .filter(m -> m.getElenco().stream()
                        .anyMatch(ator -> ator.toLowerCase()
                                .contains(searchTerm.toLowerCase())))
                .collect(Collectors.toList());

        String message = resultados.isEmpty()
                ? "Mídias não encontradas"
                : "Busca por Elenco: " + searchTerm;

        return new SearchResults(resultados, message);
    }

    /**
     * Define o repositório de mídias audiovisuais que será usado nesta busca.
     *
     * @param repository Repositório de {@link MediaAudioVisual}.
     */
    public void setRepository(IRepository repository) {
        this.repository = repository;
    }
}

=========================

==========================
{src/controller/search/SearchFactory.java}
package controller.search;

/**
 * Fábrica para criação de instâncias de {@link Search} conforme o tipo de busca.
 * <p>
 * Implementações dessa interface devem retornar o objeto {@link Search} apropriado
 * para o critério de busca fornecido em {@link SearchFields}.
 * </p>
 *
 * @see Search
 * @see SearchFields
 */
public interface SearchFactory {

    /**
     * Cria uma instância de {@link Search} de acordo com o tipo de busca especificado.
     *
     * @param type Enumeração {@link SearchFields} que representa o critério de busca
     *             (ex.: TUDO, TITULO, ANO_LANCAMENTO, GENERO etc.).
     * @return Objeto {@link Search} configurado para executar a busca desejada,
     *         ou {@code null} se o tipo não for suportado.
     */
    Search createSearch(SearchFields type);
}

=========================

==========================
{src/controller/search/SearchFields.java}
package controller.search;

/**
 * Enumeração que define os campos disponíveis para busca em repositórios de mídia.
 * Cada constante representa um critério de pesquisa e possui um nome legível
 * que pode ser apresentado em interfaces ou logs.
 *
 * @see SearchFactory
 * @see Search
 * @see SearchResults
 */
public enum SearchFields {

    /** Retorna todos os itens sem aplicar filtro específico. */
    TUDO("tudo"),

    /** Busca pelo título da mídia. */
    TITULO("Título"),

    /** Busca pelo(s) gênero(s) associado(s) à mídia. */
    GENERO("Gênero"),

    /** Busca pelo ano de lançamento da mídia. */
    ANO_LANCAMENTO("Ano de Lançamento"),

    /** Busca pelo nome do diretor (aplicável a mídias audiovisuais). */
    DIRETOR("Diretor"),

    /** Busca pelo nome do autor (aplicável a livros). */
    AUTOR("Autor"),

    /** Busca pelo código ISBN (aplicável a livros). */
    ISBN("ISBN"),

    /** Busca pela duração da mídia em minutos. */
    DURACAO("Duração"),

    /** Busca por membros do elenco (aplicável a mídias audiovisuais). */
    ELENCO("Elenco"),

    /** Busca pela descrição do roteiro ou sinopse. */
    ROTEIRO("Roteiro");

    /** Nome legível para apresentação do campo de busca. */
    private final String fieldName;

    /**
     * Construtor da enumeração.
     *
     * @param descricao Nome legível do campo de busca.
     */
    SearchFields(String descricao) {
        this.fieldName = descricao;
    }

    /**
     * Recupera o nome legível associado ao campo de busca.
     *
     * @return Descrição ou rótulo do campo de busca.
     */
    public String getFieldName() {
        return fieldName;
    }
}

=========================

==========================
{src/controller/search/SearchGenre.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Media;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementação de {@link Search} que realiza buscas de mídias por gênero.
 * <p>
 * Executa a pesquisa sobre um repositório de {@link Media}, filtrando aqueles
 * que possuem ao menos um gênero cujo nome corresponde (case-insensitive)
 * ao termo de busca fornecido.
 * </p>
 *
 * @see Search
 * @see SearchResults
 * @see IRepository
 * @see Media
 */
public class SearchGenre implements Search {

    /**
     * Repositório de mídias usado na pesquisa.
     */
    private IRepository repository;

    /**
     * Executa a busca de mídias cujo gênero contém o termo fornecido.
     *
     * @param searchTerm Termo de busca para o nome do gênero.
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *             <li>Lista de mídias cujo gênero corresponde ao termo;</li>
     *             <li>Mensagem de status indicando o resultado da busca.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        // Copia todos os itens do repositório
        List<Media> medias = new ArrayList<>(repository.getItems());

        // Filtra pelas mídias que possuem o gênero buscado
        medias = medias.stream()
                .filter(media -> media.getGeneros().stream()
                        .anyMatch(genero -> genero.getNome()
                                .equalsIgnoreCase(searchTerm)))
                .collect(Collectors.toList());

        // Monta a mensagem de retorno
        String message = medias.isEmpty()
                ? "Mídias não encontradas"
                : "Busca por Gênero: " + searchTerm;

        return new SearchResults(medias, message);
    }

    /**
     * Define o repositório de mídias que será usado nesta busca.
     *
     * @param repository Repositório de {@link Media}.
     */
    public void setRepository(IRepository repository) {
        this.repository = repository;
    }
}

=========================

==========================
{src/controller/search/SearchISBN.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Livro;
import model.Media;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementação de {@link Search} que realiza buscas de livros pelo código ISBN.
 * <p>
 * Executa a pesquisa sobre um repositório de {@link Livro}, filtrando aqueles
 * cujo ISBN contém o termo de busca (case-insensitive), e retorna os resultados
 * como uma lista de {@link Media}.
 * </p>
 *
 * @see Search
 * @see SearchResults
 * @see IRepository
 * @see Livro
 */
public class SearchISBN implements Search {

    /**
     * Repositório de livros usado na pesquisa.
     */
    private IRepository<Livro> livroRepository;

    /**
     * Executa a busca de livros cujo ISBN contém o termo fornecido.
     *
     * @param searchTerm Termo de busca para o código ISBN.
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *           <li>Lista de mídias (livros) cujo ISBN corresponde ao termo;</li>
     *           <li>Mensagem de status indicando o resultado da busca.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        List<Media> medias = livroRepository.getItems().stream()
                .filter(livro -> livro.getIsbn()
                        .toLowerCase()
                        .contains(searchTerm.toLowerCase()))
                .collect(Collectors.toList());

        String message = medias.isEmpty()
                ? "Mídias não encontradas"
                : "Busca por ISBN: " + searchTerm;

        return new SearchResults(medias, message);
    }

    /**
     * Define o repositório de livros que será usado nesta busca.
     *
     * @param livroRepository Repositório de {@link Livro}.
     */
    public void setRepository(IRepository<Livro> livroRepository) {
        this.livroRepository = livroRepository;
    }
}

=========================

==========================
{src/controller/search/SearchResults.java}
package controller.search;

import model.Media;
import java.util.List;

/**
 * Representa os resultados de uma operação de busca.
 * <p>
 * Contém a lista de mídias encontradas e uma mensagem de status ou descrição
 * sobre o resultado da busca.
 * </p>
 *
 * @see Media
 */
public class SearchResults {

    /**
     * Lista de mídias que satisfazem o critério de busca.
     */
    private List<Media> mediaList;

    /**
     * Mensagem de status ou descrição associada aos resultados da busca.
     */
    private String message;

    /**
     * Constrói um novo objeto {@code SearchResults} com a lista de mídias e a mensagem fornecidas.
     *
     * @param mediaList lista de mídias retornadas pela busca
     * @param message   mensagem de status ou descrição dos resultados
     */
    public SearchResults(List<Media> mediaList, String message) {
        this.mediaList = mediaList;
        this.message = message;
    }

    /**
     * Retorna a lista de mídias encontradas na busca.
     *
     * @return lista de {@link Media}
     */
    public List<Media> getMediaList() {
        return mediaList;
    }

    /**
     * Substitui a lista de mídias pelos novos resultados.
     *
     * @param mediaList nova lista de mídias
     */
    public void setMediaList(List<Media> mediaList) {
        this.mediaList = mediaList;
    }

    /**
     * Retorna a mensagem de status ou descrição dos resultados da busca.
     *
     * @return mensagem associada à busca
     */
    public String getMessage() {
        return message;
    }

    /**
     * Atualiza a mensagem de status ou descrição dos resultados da busca.
     *
     * @param message nova mensagem a ser associada
     */
    public void setMessage(String message) {
        this.message = message;
    }

    /**
     * Verifica se não há mídias na lista de resultados.
     *
     * @return {@code true} se a lista de mídias estiver vazia, {@code false} caso contrário
     */
    public boolean isEmpty() {
        return mediaList == null || mediaList.isEmpty();
    }
}

=========================

==========================
{src/controller/search/SearchTitle.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Media;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementação de {@link Search} que realiza buscas de mídias pelo título.
 * <p>
 * Executa a pesquisa sobre um repositório de {@link Media}, filtrando aqueles
 * cujo título contém o termo de busca (case-insensitive), e retorna os resultados
 * como uma lista de mídias.
 * </p>
 *
 * @see Search
 * @see SearchResults
 * @see IRepository
 * @see Media
 */
public class SearchTitle implements Search {

    /**
     * Repositório de mídias usado na pesquisa.
     */
    private IRepository repository;

    /**
     * Executa a busca de mídias cujo título contém o termo fornecido.
     *
     * @param searchTerm Termo de busca para o título.
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *           <li>Lista de mídias cujo título corresponde ao termo;</li>
     *           <li>Mensagem de status indicando o resultado da busca.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        // Copia todos os itens do repositório
        List<Media> medias = new ArrayList<>(repository.getItems());

        // Filtra pelas mídias cujo título corresponde ao termo
        medias = medias.stream()
                .filter(media -> media.getTitulo()
                        .toLowerCase()
                        .contains(searchTerm.toLowerCase()))
                .collect(Collectors.toList());

        // Monta a mensagem de retorno
        String message = medias.isEmpty()
                ? "Mídias não encontradas"
                : "Busca por Título: " + searchTerm;

        return new SearchResults(medias, message);
    }

    /**
     * Define o repositório de mídias que será usado nesta busca.
     *
     * @param repository Repositório de {@link Media}.
     */
    public void setRepository(IRepository repository) {
        this.repository = repository;
    }
}

=========================

==========================
{src/controller/search/SearchYear.java}
package controller.search;

import controller.dataBase.IRepository;
import model.Media;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementação de {@link Search} que realiza buscas de mídias por ano de lançamento.
 * <p>
 * Executa a pesquisa sobre um repositório de {@link Media}, filtrando aqueles
 * cujo ano de lançamento corresponde ao termo de busca (interpretado como inteiro),
 * e retorna os resultados como uma lista de mídias.
 * </p>
 *
 * @see Search
 * @see SearchResults
 * @see IRepository
 * @see Media
 */
public class SearchYear implements Search {

    /**
     * Repositório de mídias usado na pesquisa.
     */
    private IRepository repository;

    /**
     * Executa a busca de mídias cujo ano de lançamento corresponde ao termo fornecido.
     *
     * @param searchTerm Termo de busca para o ano (deve ser um número inteiro).
     * @return Um {@link SearchResults} contendo:
     *         <ul>
     *           <li>Lista de mídias cujo ano de lançamento corresponde ao termo;</li>
     *           <li>Mensagem de status indicando o resultado da busca.</li>
     *         </ul>
     */
    @Override
    public SearchResults execute(String searchTerm) {
        // Copia todos os itens do repositório
        List<Media> medias = new ArrayList<>(repository.getItems());

        // Filtra pelas mídias cujo ano de lançamento corresponde ao termo
        int year = Integer.parseInt(searchTerm);
        medias = medias.stream()
                .filter(media -> media.getDataLancamento().getYear() == year)
                .collect(Collectors.toList());

        // Monta a mensagem de retorno
        String message = medias.isEmpty()
                ? "Mídias não encontradas"
                : "Busca por Ano: " + searchTerm;

        return new SearchResults(medias, message);
    }

    /**
     * Define o repositório de mídias que será usado nesta busca.
     *
     * @param repository Repositório de {@link Media}.
     */
    public void setRepository(IRepository repository) {
        this.repository = repository;
    }
}

=========================

==========================
{src/controller/search/filme/SearchFilmeController.java}
package controller.search.filme;

import controller.search.SearchController;
import controller.search.SearchFields;

/**
 * A classe {@code SearchFilmeController} é responsável por controlar as buscas específicas para filmes.
 * Ela estende a classe {@code SearchController}, fornecendo um controle especializado para realizar
 * buscas de filmes com base em um termo de busca e um campo de busca específico.
 *
 * @see controller.search.SearchController
 * @see controller.search.SearchFields
 */
public class SearchFilmeController extends SearchController {

    /**
     * Construtor da classe {@code SearchFilmeController}.
     * Inicializa a busca para filmes, configurando o termo de busca e o campo de busca a ser utilizado.
     * A fábrica de busca específica para filmes também é configurada.
     *
     * @param searchTerm o termo de busca (exemplo: título, diretor)
     * @param searchField o campo de busca onde o termo será aplicado (exemplo: nome do filme, diretor)
     */
    public SearchFilmeController(String searchTerm, SearchFields searchField) {
        super(searchTerm, searchField);
        searchFactory = new SearchFilmeFactory();
    }
}

=========================

==========================
{src/controller/search/filme/SearchFilmeFactory.java}
package controller.search.filme;

import controller.dataBase.FilmeRepository;
import controller.search.*;

/**
 * Fábrica de buscas específicas para filmes.
 *
 * Esta classe implementa {@link SearchFactory} e é responsável por criar instâncias
 * de buscas configuradas para filmes, de acordo com o critério definido em {@link SearchFields}.
 * Ela encapsula a obtenção do repositório de filmes e a configuração básica de cada busca.
 *
 * @see SearchFactory
 * @see SearchFields
 * @see FilmeRepository
 */
public class SearchFilmeFactory implements SearchFactory {
    // Instância do repositório de filmes
    private final FilmeRepository filmeRepository = FilmeRepository.getInstance();

    /**
     * Cria e retorna um objeto {@link Search} adequado para o tipo de busca especificado.
     *
     * @param type O campo de busca definido em {@link SearchFields}.
     * @return Uma implementação de {@link Search} configurada com o repositório de filmes,
     *         ou {@code null} se o tipo não for reconhecido.
     */
    @Override
    public Search createSearch(SearchFields type) {
        switch (type) {
            case type.TUDO -> {
                SearchAll searchAll = new SearchAll();
                searchAll.setRepository(filmeRepository);
                return searchAll;
            }
            case type.TITULO -> {
                SearchTitle searchTitle = new SearchTitle();
                searchTitle.setRepository(filmeRepository);
                return searchTitle;
            }
            case type.ANO_LANCAMENTO -> {
                SearchYear searchYear = new SearchYear();
                searchYear.setRepository(filmeRepository);
                return searchYear;
            }
            case type.GENERO -> {
                SearchGenre searchGenre = new SearchGenre();
                searchGenre.setRepository(filmeRepository);
                return searchGenre;
            }
            case type.DIRETOR -> {
                SearchDirector searchDirector = new SearchDirector();
                searchDirector.setRepository(filmeRepository);
                return searchDirector;
            }
            case type.ELENCO -> {
                SearchElenco searchElenco = new SearchElenco();
                searchElenco.setRepository(filmeRepository);
                return searchElenco;
            }
            default -> {
                // Tipo de busca não suportado
            }
        }
        return null;
    }
}

=========================

==========================
{src/controller/search/livro/SearchLivroController.java}
package controller.search.livro;

import controller.search.SearchController;
import controller.search.SearchFields;

/**
 * Controlador de buscas para livros.
 * <p>
 * Estende {@link SearchController} fornecendo um ponto de entrada específico
 * para buscas na coleção de livros. Este controlador encapsula o termo de busca
 * e o campo a ser pesquisado e utiliza {@link SearchLivroFactory} para criar
 * a estratégia de busca adequada.
 * </p>
 *
 * @see SearchController
 * @see SearchFields
 * @see SearchLivroFactory
 */
public class SearchLivroController extends SearchController {

    /**
     * Constrói um novo controlador de busca para livros.
     *
     * @param searchTerm  o termo de busca (por exemplo, título, autor, ISBN, etc.)
     * @param searchField o campo de busca definido em {@link SearchFields}
     */
    public SearchLivroController(String searchTerm, SearchFields searchField) {
        super(searchTerm, searchField);
        this.searchFactory = new SearchLivroFactory();
    }
}

=========================

==========================
{src/controller/search/livro/SearchLivroFactory.java}
package controller.search.livro;

import controller.dataBase.LivroRepository;
import controller.search.*;

/**
 * Fábrica de buscas para a entidade {@link model.Livro}.
 * <p>
 * Esta classe implementa {@link SearchFactory} e fornece instâncias de buscas
 * configuradas para pesquisar livros no repositório de livros, de acordo com
 * o critério especificado em {@link SearchFields}.
 * </p>
 *
 * @see SearchFactory
 * @see SearchFields
 * @see LivroRepository
 */
public class SearchLivroFactory implements SearchFactory {

    /**
     * Instância única do repositório de livros utilizada pela fábrica.
     */
    private final LivroRepository livroRepository = LivroRepository.getInstance();

    /**
     * Cria e retorna uma estratégia de busca apropriada para o tipo de campo informado.
     *
     * @param type O campo de busca definido em {@link SearchFields}.
     * @return Uma implementação de {@link Search} configurada com o repositório de livros,
     *         ou {@code null} se o tipo não for reconhecido.
     */
    @Override
    public Search createSearch(SearchFields type) {
        switch (type) {
            case type.TUDO -> {
                SearchAll searchAll = new SearchAll();
                searchAll.setRepository(livroRepository);
                return searchAll;
            }
            case type.TITULO -> {
                SearchTitle searchTitle = new SearchTitle();
                searchTitle.setRepository(livroRepository);
                return searchTitle;
            }
            case type.ANO_LANCAMENTO -> {
                SearchYear searchYear = new SearchYear();
                searchYear.setRepository(livroRepository);
                return searchYear;
            }
            case type.GENERO -> {
                SearchGenre searchGenre = new SearchGenre();
                searchGenre.setRepository(livroRepository);
                return searchGenre;
            }
            case type.AUTOR -> {
                SearchAutor searchAutor = new SearchAutor();
                searchAutor.setRepository(livroRepository);
                return searchAutor;
            }
            case type.ISBN -> {
                SearchISBN searchISBN = new SearchISBN();
                searchISBN.setRepository(livroRepository);
                return searchISBN;
            }
            default -> {
                // Tipo de busca não suportado
            }
        }
        return null;
    }
}

=========================

==========================
{src/controller/search/serie/SearchSerieController.java}
package controller.search.serie;

import controller.search.SearchController;
import controller.search.SearchFields;

/**
 * Controlador de buscas para séries.
 * <p>
 * Estende {@link SearchController} fornecendo um ponto de entrada específico
 * para pesquisas na coleção de séries. O controlador encapsula o termo de busca
 * e o campo de pesquisa e utiliza {@link SearchSerieFactory} para criar a
 * estratégia de busca apropriada.
 * </p>
 *
 * @see SearchController
 * @see SearchFields
 * @see SearchSerieFactory
 */
public class SearchSerieController extends SearchController {

    /**
     * Constrói um novo controlador de busca para séries.
     *
     * @param searchTerm  o termo de busca (por exemplo, título, gênero, diretor, etc.)
     * @param searchField o campo de busca definido em {@link SearchFields}
     */
    public SearchSerieController(String searchTerm, SearchFields searchField) {
        super(searchTerm, searchField);
        this.searchFactory = new SearchSerieFactory();
    }
}

=========================

==========================
{src/controller/search/serie/SearchSerieFactory.java}
package controller.search.serie;

import controller.dataBase.SerieRepository;
import controller.search.*;

/**
 * Fábrica para criação de buscas relacionadas a séries.
 * A classe {@code SearchSerieFactory} implementa a interface {@code SearchFactory} e é responsável
 * por criar instâncias de {@code Search} específicas para a busca de séries em diferentes campos,
 * como título, ano de lançamento, gênero, entre outros.
 *
 * @see controller.search.SearchFactory
 * @see controller.search.Search
 * @see controller.dataBase.SerieRepository
 */
public class SearchSerieFactory implements SearchFactory {

    /**
     * Cria uma instância de busca com base no tipo de campo de pesquisa fornecido.
     * Dependendo do campo de pesquisa selecionado, a fábrica cria e retorna uma instância
     * de busca específica para séries (por exemplo, buscar por título, ano de lançamento, gênero, etc.).
     *
     * @param type o campo de pesquisa a ser utilizado (por exemplo, título, ano de lançamento, etc.)
     * @return uma instância de {@code Search} correspondente ao tipo de pesquisa especificado
     */
    @Override
    public Search createSearch(SearchFields type) {
        SerieRepository serieRepository = SerieRepository.getInstance();

        switch (type) {
            case type.TUDO:
                SearchAll searchAll = new SearchAll();
                searchAll.setRepository(serieRepository);
                return searchAll;
            case type.TITULO:
                SearchTitle searchTitle = new SearchTitle();
                searchTitle.setRepository(serieRepository);
                return searchTitle;
            case type.ANO_LANCAMENTO:
                SearchYear searchYear = new SearchYear();
                searchYear.setRepository(serieRepository);
                return searchYear;
            case type.GENERO:
                SearchGenre searchGenre = new SearchGenre();
                searchGenre.setRepository(serieRepository);
                return searchGenre;
            case type.ELENCO:
                SearchElenco searchElenco = new SearchElenco();
                searchElenco.setRepository(serieRepository);
                return searchElenco;
            default:
                return null;
        }
    }
}

=========================

==========================
{src/controller/util/DateFormater.java}
package controller.util;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Classe utilitária para formatação de datas.
 */
public class DateFormater {

    // Instância imutável e reutilizável de formatter
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy - HH:mm");

    /**
     * Retorna a data e hora formatada no padrão "dd/MM/yyyy - HH:mm".
     *
     * @param date objeto {@link LocalDateTime} a ser formatado
     * @return uma {@link String} representando a data formatada
     */
    public static String DataHora(LocalDateTime date) {
        if (date == null) {
            return "Data inválida";
        }
        return date.format(FORMATTER);
    }
}

=========================

==========================
{src/model/Avaliacao.java}
package model;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Representa uma avaliação feita por um usuário sobre um determinado item consumido.
 *
 * Contém informações como a data da avaliação, pontuação atribuída, um comentário (review)
 * e a data em que o item foi consumido.
 *
 * Pode ser utilizada em sistemas de recomendação, avaliações de filmes, produtos, etc.
 *
 */
public class Avaliacao {
    /** Data e hora em que a avaliação foi realizada. */
    private LocalDateTime dataAvaliacao;

    /** Pontuação atribuída na avaliação. */
    private int pontuacao;

    /** Comentário escrito pelo usuário sobre o item avaliado. */
    private String review;

    /** Data em que o item avaliado foi consumido. */
    private LocalDate dataConsumo;

    /**
     * Construtor padrão.
     */
    public Avaliacao() {}

    /**
     * Construtor com todos os atributos.
     *
     * @param dataAvaliacao Data e hora da avaliação.
     * @param pontuacao Pontuação atribuída.
     * @param review Comentário do usuário.
     * @param dataConsumo Data do consumo do item.
     */
    public Avaliacao(LocalDateTime dataAvaliacao, int pontuacao, String review, LocalDate dataConsumo) {
        this.dataAvaliacao = dataAvaliacao;
        this.pontuacao = pontuacao;
        this.review = review;
        this.dataConsumo = dataConsumo;
    }

    /**
     * Retorna a data e hora da avaliação.
     *
     * @return data e hora da avaliação.
     */
    public LocalDateTime getDataAvaliacao() {
        return dataAvaliacao;
    }

    /**
     * Define a data e hora da avaliação.
     *
     * @param dataAvaliacao nova data e hora da avaliação.
     */
    public void setDataAvaliacao(LocalDateTime dataAvaliacao) {
        this.dataAvaliacao = dataAvaliacao;
    }

    /**
     * Retorna a pontuação da avaliação.
     *
     * @return valor inteiro da pontuação.
     */
    public int getPontuacao() {
        return pontuacao;
    }

    /**
     * Define a pontuação da avaliação.
     *
     * @param pontuacao nova pontuação.
     */
    public void setPontuacao(int pontuacao) {
        this.pontuacao = pontuacao;
    }

    /**
     * Retorna o comentário da avaliação.
     *
     * @return texto da review.
     */
    public String getReview() {
        return review;
    }

    /**
     * Define o comentário da avaliação.
     *
     * @param review novo comentário.
     */
    public void setReview(String review) {
        this.review = review;
    }

    /**
     * Retorna a data em que o item foi consumido.
     *
     * @return data de consumo.
     */
    public LocalDate getDataConsumo() {
        return dataConsumo;
    }

    /**
     * Define a data de consumo do item avaliado.
     *
     * @param dataConsumo nova data de consumo.
     */
    public void setDataConsumo(LocalDate dataConsumo) {
        this.dataConsumo = dataConsumo;
    }
}

=========================

==========================
{src/model/Filme.java}
package model;

import model.commons.IAvaliavel;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Representa um filme como uma mídia audiovisual, contendo informações específicas
 * como direção, duração, roteiro e avaliações feitas por usuários.
 *
 * Estende a classe {@link MediaAudioVisual} e implementa a interface {@link IAvaliavel},
 * permitindo que seja avaliado por usuários.
 *
 * A pontuação retornada corresponde à mais recente avaliação realizada.
 *
 * @see Avaliacao
 * @see TipoMedia
 * @see MediaAudioVisual
 * @see IAvaliavel
 * @see Genero
 *
 */
public class Filme extends MediaAudioVisual implements IAvaliavel {

    /** Nome do diretor ou diretora do filme. */
    private String direcao;

    /** Duração do filme em minutos. */
    private int duracao;

    /** Informações sobre o roteiro ou roteirista. */
    private String roteiro;

    /** Tipo da mídia, fixado como FILME. */
    private TipoMedia tipoMedia = TipoMedia.FILME;

    /** Lista de avaliações associadas ao filme. */
    private List<Avaliacao> avaliacoes;

    /**
     * Construtor padrão.
     * Inicializa a lista de avaliações como vazia.
     */
    public Filme() {
        super();
        this.avaliacoes = new ArrayList<>();
    }

    /**
     * Construtor completo para criação de um filme com todos os detalhes.
     *
     * @param titulo Título do filme.
     * @param dataLancamento Data e hora do lançamento.
     * @param consumido Indica se o filme já foi consumido pelo usuário.
     * @param generos Lista de gêneros associados ao filme.
     * @param tituloOriginal Título original do filme.
     * @param localDisponivel Plataforma ou local onde o filme está disponível.
     * @param elenco Lista com nomes do elenco.
     * @param direcao Nome do diretor(a).
     * @param duracao Duração em minutos.
     * @param roteiro Detalhes do roteiro.
     */
    public Filme(String titulo, LocalDateTime dataLancamento, boolean consumido, List<Genero> generos,
                 String tituloOriginal, String localDisponivel, List<String> elenco, String direcao,
                 int duracao, String roteiro) {
        super(titulo, dataLancamento, consumido, generos, tituloOriginal, localDisponivel, elenco);
        this.avaliacoes = new ArrayList<>();
        this.direcao = direcao;
        this.duracao = duracao;
        this.roteiro = roteiro;
    }

    /**
     * Retorna o nome do diretor do filme.
     *
     * @return nome do diretor.
     */
    public String getDirecao() {
        return direcao;
    }

    /**
     * Define o nome do diretor do filme.
     *
     * @param direcao nome do diretor.
     */
    public void setDirecao(String direcao) {
        this.direcao = direcao;
    }

    /**
     * Retorna a duração do filme em minutos.
     *
     * @return duração em minutos.
     */
    public int getDuracao() {
        return duracao;
    }

    /**
     * Define a duração do filme em minutos.
     *
     * @param duracao nova duração.
     */
    public void setDuracao(int duracao) {
        this.duracao = duracao;
    }

    /**
     * Retorna informações sobre o roteiro.
     *
     * @return detalhes do roteiro.
     */
    public String getRoteiro() {
        return roteiro;
    }

    /**
     * Define informações sobre o roteiro.
     *
     * @param roteiro novo roteiro.
     */
    public void setRoteiro(String roteiro) {
        this.roteiro = roteiro;
    }

    /**
     * Retorna o tipo da mídia, que neste caso é sempre {@link TipoMedia#FILME}.
     *
     * @return tipo da mídia.
     */
    public TipoMedia getTipoMedia() {
        return this.tipoMedia;
    }

    /**
     * Adiciona uma nova avaliação ao filme.
     *
     * @param avaliacao avaliação a ser adicionada.
     */
    @Override
    public void avaliar(Avaliacao avaliacao) {
        avaliacoes.add(avaliacao);
    }

    /**
     * Retorna a pontuação da avaliação mais recente feita ao filme.
     *
     * @return pontuação mais recente, ou 0 se não houver avaliações.
     */
    @Override
    public double getPontuacao() {
        return avaliacoes.stream()
                .max(Comparator.comparing(Avaliacao::getDataAvaliacao))
                .map(Avaliacao::getPontuacao)
                .orElse(0);
    }

    /**
     * Retorna a lista de avaliações ordenada da mais recente para a mais antiga.
     *
     * @return lista de avaliações em ordem decrescente de data.
     */
    @Override
    public List<Avaliacao> getAvaliacoes() {
        return avaliacoes.stream()
                .sorted(Comparator.comparing(Avaliacao::getDataAvaliacao).reversed())
                .collect(Collectors.toList());
    }
}

=========================

==========================
{src/model/Genero.java}
package model;

import model.commons.Identifiable;

/**
 * Representa um gênero associado a uma mídia (ex: filme, série, música).
 *
 * Cada gênero possui um identificador único (id) e um nome descritivo (ex: "Drama", "Comédia").
 * Implementa a interface {@link Identifiable}, permitindo ser tratado como uma entidade identificável.
 *
 */
public class Genero implements Identifiable {

    /** Identificador único do gênero. */
    private int id;

    /** Nome do gênero. */
    private String nome;

    /**
     * Construtor que define o nome do gênero.
     *
     * @param nome nome descritivo do gênero.
     */
    public Genero(String nome){
        this.nome = nome;
    }

    /**
     * Retorna o nome do gênero.
     *
     * @return nome do gênero.
     */
    public String getNome() {
        return nome;
    }

    /**
     * Retorna uma representação textual do gênero.
     *
     * @return nome do gênero como string.
     */
    @Override
    public String toString(){
        return this.nome;
    }

    /**
     * Retorna o identificador do gênero.
     *
     * @return identificador inteiro.
     */
    @Override
    public int getId() {
        return id;
    }

    /**
     * Define o identificador do gênero.
     *
     * @param id novo identificador.
     */
    @Override
    public void setId(int id) {
        this.id = id;
    }
}

=========================

==========================
{src/model/Livro.java}
package model;

import model.commons.IAvaliavel;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Representa um livro como tipo de mídia que pode ser avaliado.
 * Estende a classe {@link Media} e implementa a interface {@link IAvaliavel}.
 *
 * Cada livro possui informações como autor, editora, ISBN e se está ou não na posse do usuário.
 *
 * A pontuação atribuída ao livro corresponde à avaliação mais recente.
 *
 */
public class Livro extends Media implements IAvaliavel {

    /** Nome do autor do livro. */
    private String autor;

    /** Nome da editora responsável pela publicação. */
    private String editora;

    /** Indica se o usuário possui fisicamente ou digitalmente o livro. */
    private boolean possui;

    /** Código ISBN do livro. */
    private String isbn;

    /** Tipo de mídia, fixado como LIVRO. */
    private TipoMedia tipoMedia = TipoMedia.LIVRO;

    /** Lista de avaliações feitas ao livro. */
    private List<Avaliacao> avaliacoes;

    /**
     * Construtor padrão.
     * Inicializa a lista de avaliações como vazia.
     */
    public Livro() {
        super();
        this.avaliacoes = new ArrayList<>();
    }

    /**
     * Construtor completo que inicializa todos os atributos do livro.
     *
     * @param titulo Título do livro.
     * @param dataLancamento Data de lançamento.
     * @param consumido Indica se o livro foi lido.
     * @param generosLivro Lista de gêneros associados.
     * @param autor Nome do autor.
     * @param editora Nome da editora.
     * @param possui Indica se o livro está em posse do usuário.
     * @param isbn Código ISBN do livro.
     */
    public Livro(String titulo, LocalDateTime dataLancamento, boolean consumido, List<Genero> generosLivro,
                 String autor, String editora, boolean possui, String isbn) {
        super(titulo, dataLancamento, consumido, generosLivro);
        this.autor = autor;
        this.editora = editora;
        this.possui = possui;
        this.isbn = isbn;
        this.avaliacoes = new ArrayList<>();
    }

    /**
     * Retorna o nome do autor do livro.
     *
     * @return nome do autor.
     */
    public String getAutor() {
        return autor;
    }

    /**
     * Define o nome do autor do livro.
     *
     * @param autor nome do autor.
     */
    public void setAutor(String autor) {
        this.autor = autor;
    }

    /**
     * Retorna o nome da editora.
     *
     * @return nome da editora.
     */
    public String getEditora() {
        return editora;
    }

    /**
     * Define o nome da editora.
     *
     * @param editora nome da editora.
     */
    public void setEditora(String editora) {
        this.editora = editora;
    }

    /**
     * Indica se o livro está em posse do usuário.
     *
     * @return true se estiver em posse, false caso contrário.
     */
    public boolean isPossui() {
        return possui;
    }

    /**
     * Define se o livro está em posse do usuário.
     *
     * @param possui true se estiver em posse, false caso contrário.
     */
    public void setPossui(boolean possui) {
        this.possui = possui;
    }

    /**
     * Retorna o código ISBN do livro.
     *
     * @return código ISBN.
     */
    public String getIsbn() {
        return isbn;
    }

    /**
     * Define o código ISBN do livro.
     *
     * @param isbn código ISBN.
     */
    public void setIsbn(String isbn) {
        this.isbn = isbn;
    }

    /**
     * Retorna o tipo da mídia, que neste caso é {@link TipoMedia#LIVRO}.
     *
     * @return tipo da mídia.
     */
    @Override
    public TipoMedia getTipoMedia() {
        return this.tipoMedia;
    }

    /**
     * Retorna a lista de avaliações feitas ao livro, ordenada da mais recente para a mais antiga.
     *
     * @return lista de avaliações.
     */
    @Override
    public List<Avaliacao> getAvaliacoes() {
        return avaliacoes.stream()
                .sorted(Comparator.comparing(Avaliacao::getDataAvaliacao).reversed())
                .collect(Collectors.toList());
    }

    /**
     * Retorna a pontuação da avaliação mais recente feita ao livro.
     *
     * @return pontuação mais recente ou 0 caso não haja avaliações.
     */
    @Override
    public double getPontuacao() {
        return avaliacoes.stream()
                .max(Comparator.comparing(Avaliacao::getDataAvaliacao))
                .map(Avaliacao::getPontuacao)
                .orElse(0);
    }

    /**
     * Adiciona uma nova avaliação ao livro.
     *
     * @param avaliacao avaliação a ser adicionada.
     */
    @Override
    public void avaliar(Avaliacao avaliacao) {
        avaliacoes.add(avaliacao);
    }
}

=========================

==========================
{src/model/Media.java}
package model;

import model.commons.IAvaliavel;
import model.commons.ITemAvaliacao;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Classe abstrata que representa uma mídia genérica (ex: livro, filme, série).
 * Implementa a interface {@link ITemAvaliacao} e pode ser estendida por mídias avaliáveis.
 *
 * Armazena informações comuns a todas as mídias como título, data de lançamento, gêneros e estado de consumo.
 *
 */
public abstract class Media implements ITemAvaliacao {

    /** Identificador único da mídia. */
    private int id = -1;

    /** Título da mídia. */
    private String titulo;

    /** Data de lançamento da mídia. */
    private LocalDateTime dataLancamento;

    /** Lista de gêneros associados à mídia. */
    private List<Genero> generos;

    /** Indica se a mídia já foi consumida (ex: lida, assistida). */
    private boolean consumido;

    /** Tipo da mídia (ex: LIVRO, FILME). */
    private TipoMedia tipoMedia;

    /**
     * Construtor padrão que inicializa a lista de gêneros vazia
     * e define a mídia como não consumida.
     */
    public Media() {
        this.generos = new ArrayList<>();
        this.consumido = false;
    }

    /**
     * Construtor com parâmetros para inicialização completa da mídia.
     *
     * @param titulo Título da mídia.
     * @param dataLancamento Data de lançamento.
     * @param consumido Indica se a mídia já foi consumida.
     * @param generos Lista de gêneros associados à mídia.
     */
    public Media(String titulo, LocalDateTime dataLancamento, boolean consumido, List<Genero> generos) {
        this();
        if (generos != null) {
            for (Genero genero : generos) {
                addGenero(genero);
            }
        }
        this.titulo = titulo;
        this.dataLancamento = dataLancamento;
        this.consumido = consumido;
    }

    /**
     * Retorna o ID da mídia.
     *
     * @return ID da mídia.
     */
    @Override
    public int getId() {
        return id;
    }

    /**
     * Define o ID da mídia.
     *
     * @param id novo ID da mídia.
     */
    @Override
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Retorna o título da mídia.
     *
     * @return título da mídia.
     */
    public String getTitulo() {
        return titulo;
    }

    /**
     * Define o título da mídia.
     *
     * @param titulo novo título.
     */
    public void setTitulo(String titulo) {
        this.titulo = titulo;
    }

    /**
     * Retorna a data de lançamento da mídia.
     *
     * @return data de lançamento.
     */
    public LocalDateTime getDataLancamento() {
        return dataLancamento;
    }

    /**
     * Define a data de lançamento da mídia.
     *
     * @param dataLancamento nova data de lançamento.
     */
    public void setDataLancamento(LocalDateTime dataLancamento) {
        this.dataLancamento = dataLancamento;
    }

    /**
     * Retorna uma cópia da lista de gêneros da mídia.
     *
     * @return lista de gêneros.
     */
    public List<Genero> getGeneros() {
        return new ArrayList<>(generos);
    }

    /**
     * Adiciona um gênero à lista de gêneros da mídia.
     *
     * @param genero gênero a ser adicionado.
     */
    public void addGenero(Genero genero) {
        if (genero != null) {
            generos.add(genero);
        }
    }

    /**
     * Define a lista de gêneros da mídia.
     *
     * @param generos nova lista de gêneros.
     */
    public void setGeneros(List<Genero> generos) {
        if (generos != null) {
            this.generos = new ArrayList<>(generos);
        }
    }

    /**
     * Retorna se a mídia foi consumida.
     *
     * @return true se consumida, false caso contrário.
     */
    public boolean isConsumido() {
        return consumido;
    }

    /**
     * Define se a mídia foi consumida.
     *
     * @param consumido true para consumida, false caso contrário.
     */
    public void setConsumido(boolean consumido) {
        this.consumido = consumido;
    }
}

=========================

==========================
{src/model/MediaAudioVisual.java}
package model;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Classe abstrata que representa mídias audiovisuais (como filmes, séries).
 * Extende a classe {@link Media} e adiciona atributos e métodos específicos para mídias audiovisuais.
 *
 * Atributos como elenco, título original e local de disponibilidade são específicos para esse tipo de mídia.
 *
 */
public abstract class MediaAudioVisual extends Media {

    /** Lista de nomes do elenco da mídia. */
    private List<String> elenco;

    /** Título original da mídia (caso seja diferente do título em outro idioma). */
    private String tituloOriginal;

    /** Local onde a mídia está disponível (ex: plataforma de streaming, loja física). */
    private String localDisponivel;

    /**
     * Construtor padrão que inicializa a lista de elenco como vazia.
     */
    public MediaAudioVisual() {
        super();
        this.elenco = new ArrayList<>();
    }

    /**
     * Construtor com parâmetros para inicialização completa da mídia audiovisual.
     *
     * @param titulo Título da mídia.
     * @param dataLancamento Data de lançamento da mídia.
     * @param consumido Indica se a mídia já foi consumida.
     * @param generos Lista de gêneros associados à mídia.
     * @param tituloOriginal Título original da mídia.
     * @param localDisponivel Local onde a mídia está disponível.
     * @param elenco Lista de nomes do elenco da mídia.
     */
    public MediaAudioVisual(String titulo, LocalDateTime dataLancamento, boolean consumido, List<Genero> generos,
                            String tituloOriginal, String localDisponivel, List<String> elenco) {

        super(titulo, dataLancamento, consumido, generos); // Chama o construtor da classe pai
        this.tituloOriginal = tituloOriginal;
        this.localDisponivel = localDisponivel;
        this.elenco = (elenco != null) ? new ArrayList<>(elenco) : new ArrayList<>();
    }

    /**
     * Retorna uma cópia da lista de elenco da mídia.
     *
     * @return Lista do elenco.
     */
    public List<String> getElenco() {
        return new ArrayList<>(elenco); // Retorna uma cópia para evitar modificações externas
    }

    /**
     * Define o elenco da mídia.
     *
     * @param elenco nova lista de atores/atrizes do elenco.
     */
    public void setElenco(List<String> elenco) {
        if (elenco != null) {
            this.elenco = new ArrayList<>(elenco);
        }
    }

    /**
     * Adiciona um ator ou atriz ao elenco da mídia.
     *
     * @param ator Nome do ator ou atriz a ser adicionado.
     */
    public void addElenco(String ator) {
        if (ator != null && !ator.trim().isEmpty()) {
            this.elenco.add(ator);
        }
    }

    /**
     * Retorna o título original da mídia.
     *
     * @return Título original.
     */
    public String getTituloOriginal() {
        return tituloOriginal;
    }

    /**
     * Define o título original da mídia.
     *
     * @param tituloOriginal novo título original.
     */
    public void setTituloOriginal(String tituloOriginal) {
        this.tituloOriginal = tituloOriginal;
    }

    /**
     * Retorna o local onde a mídia está disponível.
     *
     * @return Local de disponibilidade (ex: plataforma de streaming).
     */
    public String getLocalDisponivel() {
        return localDisponivel;
    }

    /**
     * Define o local onde a mídia está disponível.
     *
     * @param localDisponivel novo local de disponibilidade.
     */
    public void setLocalDisponivel(String localDisponivel) {
        this.localDisponivel = localDisponivel;
    }
}

=========================

==========================
{src/model/Serie.java}
package model;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Representa uma série de mídia, estendendo {@link MediaAudioVisual}.
 * Inclui atributos como data de término, temporadas, e métodos para avaliação.
 * Esta classe também implementa {@link Cloneable} para permitir clonagem de instâncias.
 *
 * A classe contém métodos para gerenciar temporadas e calcular pontuação média das temporadas.
 *
 */
public class Serie extends MediaAudioVisual implements Cloneable {

    /** ID da temporada atual. */
    private int temporadaId = 0;

    /** Data de término da série. */
    private LocalDateTime dataFim;

    /** Lista de temporadas da série. */
    private List<Temporada> temporadas;

    /** Tipo de mídia, fixado como "SÉRIE". */
    private TipoMedia tipoMedia = TipoMedia.SERIE;

    /**
     * Construtor padrão que inicializa a lista de temporadas.
     */
    public  Serie() {
        super();
        this.temporadas = new ArrayList<>();
    }

    /**
     * Construtor com parâmetros para inicializar uma série com título, data de lançamento,
     * elenco, e outros atributos específicos de uma série.
     *
     * @param titulo Título da série.
     * @param dataLancamento Data de lançamento da série.
     * @param consumido Indica se a série foi consumida.
     * @param generos Lista de gêneros associados à série.
     * @param tituloOriginal Título original da série.
     * @param localDisponivel Local onde a série está disponível.
     * @param elenco Lista de elenco da série.
     * @param dataFim Data de término da série.
     */
    public Serie(String titulo, LocalDateTime dataLancamento, boolean consumido,
                 List<Genero> generos, String tituloOriginal, String localDisponivel,
                 List<String> elenco, LocalDateTime dataFim) {
        super(titulo, dataLancamento, consumido, generos, tituloOriginal, localDisponivel, elenco);
        this.dataFim = dataFim;
        this.temporadas = new ArrayList<>();
    }

    /**
     * Retorna a data de término da série.
     *
     * @return Data de término.
     */
    public LocalDateTime getDataFim() {
        return dataFim;
    }

    /**
     * Define a data de término da série.
     *
     * @param dataFim Nova data de término.
     */
    public void setDataFim(LocalDateTime dataFim) {
        this.dataFim = dataFim;
    }

    /**
     * Retorna a lista de temporadas da série.
     *
     * @return Lista de temporadas.
     */
    public List<Temporada> getTemporadas() {
        return temporadas;
    }

    /**
     * Define as temporadas da série, atribuindo um ID único para cada temporada.
     *
     * @param temporadas Lista de temporadas a ser atribuída.
     */
    public void setTemporadas(List<Temporada> temporadas) {
        this.temporadas = temporadas.stream()
                .peek(temporada -> {
                    temporada.setId(temporadaId++);
                    temporada.setSerieId(getId());
                })
                .collect(java.util.stream.Collectors.toList());
    }

    /**
     * Retorna o tipo de mídia (Série).
     *
     * @return Tipo de mídia (Série).
     */
    @Override
    public TipoMedia getTipoMedia() {
        return this.tipoMedia;
    }

    /**
     * Calcula a pontuação média das temporadas da série.
     * Caso a série tenha temporadas, a média das pontuações será retornada.
     * Caso contrário, retorna 0.
     *
     * @return Pontuação média das temporadas.
     */
    @Override
    public double getPontuacao() {
        if (!temporadas.isEmpty()) {
            return temporadas.stream()
                    .mapToDouble(Temporada::getPontuacao)
                    .sum() / temporadas.size();
        } else {
            return 0;
        }
    }

    /**
     * Atualiza uma temporada existente na lista de temporadas da série com base no ID da temporada.
     *
     * @param id ID da temporada a ser atualizada.
     * @param temporada Nova temporada a ser inserida.
     */
    public void updateTemporadaById(int id, Temporada temporada) {
        for (int i = 0; i < temporadas.size(); i++) {
            if (temporadas.get(i).getId() == id) {
                temporadas.set(i, temporada);
                break;
            }
        }
    }

    /**
     * Retorna uma temporada específica com base no ID fornecido.
     *
     * @param id ID da temporada a ser retornada.
     * @return Temporada correspondente ao ID fornecido, ou null se não encontrada.
     */
    public Temporada getTemporadaById(int id) {
        for (int i = 0; i < temporadas.size(); i++) {
            if (temporadas.get(i).getId() == id) {
                return temporadas.get(i);
            }
        }
        return null;
    }

    /**
     * Adiciona uma nova temporada à série, atribuindo um ID único e associando-a à série.
     *
     * @param t Temporada a ser adicionada.
     */
    public void addTemporada(Temporada t) {
        t.setId(temporadaId++);
        t.setSerieId(getId());
        temporadas.add(t);
    }
}

=========================

==========================
{src/model/Temporada.java}
package model;

import model.commons.IAvaliavel;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Representa uma temporada de uma série de mídia, implementando a interface {@link IAvaliavel}.
 * A temporada tem atributos como o número de episódios, ano de lançamento, avaliações dos usuários,
 * e a associação com uma série específica.
 *
 * Esta classe oferece métodos para avaliar a temporada, calcular sua pontuação e manipular suas avaliações.
 *
 * @author
 */
public class Temporada implements IAvaliavel {

    /** ID da temporada. */
    private int id;

    /** Ano de lançamento da temporada. */
    private LocalDateTime ano;

    /** Quantidade de episódios na temporada. */
    private int qEpisodios;

    /** ID da série à qual esta temporada pertence. */
    private int serieId;

    /** Tipo de mídia, fixado como "TEMPORADA". */
    private TipoMedia tipoMedia = TipoMedia.TEMPORADA;

    /** Lista de avaliações da temporada. */
    private List<Avaliacao> avaliacoes;

    /**
     * Construtor padrão que inicializa a lista de avaliações.
     */
    public Temporada() {
        this.avaliacoes = new ArrayList<>();
    }

    /**
     * Construtor com parâmetros para inicializar uma temporada com quantidade de episódios e ano de lançamento.
     *
     * @param qEpisodios Quantidade de episódios da temporada.
     * @param ano Ano de lançamento da temporada.
     */
    public Temporada(int qEpisodios, LocalDateTime ano) {
        this.qEpisodios = qEpisodios;
        this.ano = ano;
        this.avaliacoes = new ArrayList<>();
    }

    /**
     * Retorna a quantidade de episódios da temporada.
     *
     * @return Quantidade de episódios.
     */
    public int getqEpisodios() {
        return qEpisodios;
    }

    /**
     * Define a quantidade de episódios da temporada.
     *
     * @param qEpisodios Nova quantidade de episódios.
     */
    public void setqEpisodios(int qEpisodios) {
        this.qEpisodios = qEpisodios;
    }

    /**
     * Retorna o ano de lançamento da temporada.
     *
     * @return Ano de lançamento.
     */
    public LocalDateTime getAno() {
        return ano;
    }

    /**
     * Define o ano de lançamento da temporada.
     *
     * @param ano Novo ano de lançamento.
     */
    public void setAno(LocalDateTime ano) {
        this.ano = ano;
    }

    /**
     * Retorna o ID da série à qual a temporada pertence.
     *
     * @return ID da série.
     */
    public int getSerieId() {
        return serieId;
    }

    /**
     * Define o ID da série à qual a temporada pertence.
     *
     * @param serieId ID da série.
     */
    public void setSerieId(int serieId) {
        this.serieId = serieId;
    }

    /**
     * Retorna o ID da temporada.
     *
     * @return ID da temporada.
     */
    @Override
    public int getId() {
        return id;
    }

    /**
     * Define o ID da temporada.
     *
     * @param id Novo ID da temporada.
     */
    @Override
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Retorna o tipo de mídia (TEMPORADA).
     *
     * @return Tipo de mídia.
     */
    @Override
    public TipoMedia getTipoMedia() {
        return tipoMedia;
    }

    /**
     * Adiciona uma avaliação à temporada.
     *
     * @param avaliacao Avaliação a ser adicionada.
     */
    @Override
    public void avaliar(Avaliacao avaliacao) {
        avaliacoes.add(avaliacao);
    }

    /**
     * Retorna a pontuação mais recente da temporada, baseada na avaliação mais recente.
     * Se não houver avaliações, retorna 0.
     *
     * @return Pontuação da temporada.
     */
    @Override
    public double getPontuacao() {
        return avaliacoes.stream()
                .max(Comparator.comparing(Avaliacao::getDataAvaliacao))
                .map(Avaliacao::getPontuacao)
                .orElse(0);
    }

    /**
     * Retorna a lista de avaliações da temporada, ordenada pela data de avaliação em ordem decrescente.
     *
     * @return Lista de avaliações ordenadas.
     */
    @Override
    public List<Avaliacao> getAvaliacoes() {
        return avaliacoes.stream()
                .sorted(Comparator.comparing(Avaliacao::getDataAvaliacao).reversed())
                .collect(Collectors.toList());
    }
}

=========================

==========================
{src/model/TipoMedia.java}
package model;

/**
 * Enum que representa os tipos de mídia disponíveis no sistema, com uma descrição associada a cada tipo.
 * Os tipos de mídia incluem: Livro, Filme, Série e Temporada.
 *
 * Cada tipo de mídia tem uma descrição associada, que pode ser utilizada para representar o tipo de forma legível.
 *
 * <p>Exemplo de uso:</p>
 * <pre>
 * TipoMedia tipo = TipoMedia.LIVRO;
 * System.out.println(tipo.getDescricao()); // Saída: "Livro"
 * </pre>
 *
 * @author
 */
public enum TipoMedia {

    /** Tipo de mídia: Livro. */
    LIVRO("Livro"),

    /** Tipo de mídia: Filme. */
    FILME("Filme"),

    /** Tipo de mídia: Série. */
    SERIE("Serie"),

    /** Tipo de mídia: Temporada. */
    TEMPORADA("Temporada");

    /** Descrição associada ao tipo de mídia. */
    private String descricao;

    /**
     * Construtor do enum que inicializa a descrição de cada tipo de mídia.
     *
     * @param descricao Descrição do tipo de mídia.
     */
    TipoMedia(String descricao) {
        this.descricao = descricao;
    }

    /**
     * Retorna a descrição do tipo de mídia.
     *
     * @return Descrição do tipo de mídia.
     */
    public String getDescricao() {
        return descricao;
    }
}

=========================

==========================
{src/model/commons/IAvaliavel.java}
package model.commons;

import model.Avaliacao;
import java.util.List;

/**
 * Interface que define o comportamento de uma entidade que pode ser avaliada.
 */
public interface IAvaliavel extends ITemAvaliacao {

    /**
     * Adiciona uma avaliação à entidade.
     *
     * @param avaliacao A avaliação a ser adicionada.
     */
    void avaliar(Avaliacao avaliacao);

    /**
     * Retorna a lista de avaliações da entidade.
     *
     * @return Lista de avaliações.
     */
    List<Avaliacao> getAvaliacoes();
}

=========================

==========================
{src/model/commons/Identifiable.java}
package model.commons;

/**
 * Interface que define um identificador único para uma entidade.
 */
public interface Identifiable {

    /**
     * Retorna o identificador da entidade.
     *
     * @return o ID da entidade
     */
    int getId();

    /**
     * Define o identificador da entidade.
     *
     * @param id o novo ID da entidade
     */
    void setId(int id);
}

=========================

==========================
{src/model/commons/ITemAvaliacao.java}
package model.commons;

import model.TipoMedia;

/**
 * Interface que define um contrato para objetos que possuem avaliação.
 *
 * Objetos que implementam esta interface devem ser identificáveis (via {@link Identifiable})
 * e devem fornecer uma pontuação e o tipo de média utilizada na avaliação.
 *
 */
public interface ITemAvaliacao extends Identifiable {

    /**
     * Retorna a pontuação associada ao objeto.
     *
     * @return um valor decimal representando a pontuação.
     */
    double getPontuacao();

    /**
     * Retorna o tipo de média utilizada para calcular a pontuação do objeto.
     *
     * @return um valor do enum {@link TipoMedia} representando o tipo de média.
     */
    TipoMedia getTipoMedia();
}

=========================

==========================
{src/tests/controller/action/avaliacao/CreateAvaliacaoActionTest.java}
package tests.controller.action.avaliacao;

import controller.action.ActionResult;
import controller.action.avaliacao.CreateAvaliacaoAction;
import controller.action.avaliacao.CreateAvaliacaoValidation;
import controller.dataBase.FilmeRepository;
import controller.dataBase.SerieRepository;
import controller.dataBase.LivroRepository;
import model.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

public class CreateAvaliacaoActionTest {

    private CreateAvaliacaoValidation validation;
    private CreateAvaliacaoAction action;
    private Avaliacao avaliacaoValida;

    @BeforeEach
    void setUp() {
        validation = new CreateAvaliacaoValidation();
        action = new CreateAvaliacaoAction(validation);

        avaliacaoValida = new Avaliacao();
        avaliacaoValida.setDataAvaliacao(LocalDateTime.now());
        avaliacaoValida.setPontuacao(4);
        avaliacaoValida.setReview("Muito bom");
        avaliacaoValida.setDataConsumo(LocalDate.now());
    }

    @Test
    void testValidacaoPontuacaoInvalida() {
        Avaliacao avaliacaoInvalida = new Avaliacao();
        avaliacaoInvalida.setDataAvaliacao(LocalDateTime.now());
        avaliacaoInvalida.setPontuacao(0);
        avaliacaoInvalida.setReview("Ruim");
        avaliacaoInvalida.setDataConsumo(LocalDate.now());

        ActionResult result = action.execute(avaliacaoInvalida);
        assertFalse(result.isSuccess());
    }

    @Test
    void testAvaliacaoComFilme() {
        Filme filme = new Filme();
        filme.setTitulo("Interestelar");

        Genero generoFiccao = new Genero("Ficção científica");
        filme.setGeneros(Collections.singletonList(generoFiccao));

        filme.setDataLancamento(LocalDateTime.of(2014, 11, 7, 0, 0));
        filme.setId(0);

        FilmeRepository.getInstance().add(filme);

        action.setSuperModel(filme);
        ActionResult result = action.execute(avaliacaoValida);

        assertTrue(result.isSuccess());
        assertEquals(1, filme.getAvaliacoes().size());
        assertEquals(avaliacaoValida.getPontuacao(), filme.getPontuacao());
    }

    @Test
    void testAvaliacaoComLivro() {
        Livro livro = new Livro();
        livro.setTitulo("O Hobbit");

        Genero generoFantasia = new Genero("Fantasia");
        livro.addGenero(generoFantasia);

        livro.setAutor("J.R.R. Tolkien");
        livro.setId(0);

        LivroRepository.getInstance().add(livro);

        action.setSuperModel(livro);
        ActionResult result = action.execute(avaliacaoValida);

        assertTrue(result.isSuccess());
        assertEquals(1, livro.getAvaliacoes().size());
    }

    @Test
    void testAvaliacaoComTemporada() {
        Temporada temporada = new Temporada();
        temporada.setqEpisodios(8);
        temporada.setAno(LocalDateTime.of(2020, 5, 1, 0, 0));
        temporada.setId(0);
        temporada.setSerieId(0);

        Serie serie = new Serie();
        serie.setTitulo("Stranger Things");
        serie.setId(0);

        SerieRepository.getInstance().add(serie);
        serie.addTemporada(temporada);

        action.setSuperModel(temporada);

        ActionResult result = action.execute(avaliacaoValida);

        assertTrue(result.isSuccess());

        Serie serieAtualizada = SerieRepository.getInstance().getItemById(0);
        assertNotNull(serieAtualizada);
        assertEquals(1, serieAtualizada.getTemporadas().get(0).getAvaliacoes().size());
    }

    @Test
    void testSuperModelNulo() {
        action.setSuperModel(null);
        ActionResult result = action.execute(avaliacaoValida);

        assertFalse(result.isSuccess());
        assertEquals("Super model is null", result.getMessage());
    }
}

=========================

==========================
{src/tests/controller/action/avaliacao/CreateAvaliacaoValidationTest.java}
package tests.controller.action.avaliacao;

import controller.action.avaliacao.CreateAvaliacaoValidation;
import model.Avaliacao;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;

public class CreateAvaliacaoValidationTest {

    private CreateAvaliacaoValidation validation;

    @BeforeEach
    void setUp() {
        validation = new CreateAvaliacaoValidation();
    }

    @Test
    void testAvaliacaoNula() {
        boolean isValid = validation.isValid(null);
        assertFalse(isValid);
        assertEquals("Avaliacao está nula", validation.getErrorMessage());
    }

    @Test
    void testPontuacaoMenorQueUm() {
        Avaliacao avaliacao = new Avaliacao();
        avaliacao.setPontuacao(0);
        avaliacao.setDataAvaliacao(LocalDateTime.now());
        avaliacao.setReview("Ruim");
        avaliacao.setDataConsumo(LocalDate.now());

        boolean isValid = validation.isValid(avaliacao);
        assertFalse(isValid);
        assertEquals("Pontuação inválida: deve estar entre 1 e 5.", validation.getErrorMessage());
    }

    @Test
    void testPontuacaoMaiorQueCinco() {
        Avaliacao avaliacao = new Avaliacao();
        avaliacao.setPontuacao(6);
        avaliacao.setDataAvaliacao(LocalDateTime.now());
        avaliacao.setReview("Excelente, mas inválida");
        avaliacao.setDataConsumo(LocalDate.now());

        boolean isValid = validation.isValid(avaliacao);
        assertFalse(isValid);
        assertEquals("Pontuação inválida: deve estar entre 1 e 5.", validation.getErrorMessage());
    }

    @Test
    void testPontuacaoValida() {
        Avaliacao avaliacao = new Avaliacao();
        avaliacao.setPontuacao(4);
        avaliacao.setDataAvaliacao(LocalDateTime.now());
        avaliacao.setReview("Muito bom");
        avaliacao.setDataConsumo(LocalDate.now());

        boolean isValid = validation.isValid(avaliacao);
        assertTrue(isValid);
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/action/filme/CreateFilmeActionTest.java}
package tests.controller.action.filme;

import controller.action.ActionResult;
import controller.action.filme.CreateFilmeAction;
import controller.action.filme.CreateFilmeValidation;
import controller.dataBase.FilmeRepository;
import model.Filme;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class CreateFilmeActionTest {

    private CreateFilmeAction action;

    @BeforeEach
    void setUp() {
        action = new CreateFilmeAction(new CreateFilmeValidation());
    }

    @Test
    void testTituloVazio() {
        Filme filme = new Filme();
        filme.setTitulo(""); // Título vazio
        filme.setGeneros(List.of(new Genero("Ação")));

        ActionResult result = action.execute(filme);

        assertFalse(result.isSuccess());
        assertEquals("Erro! título vazio", result.getMessage());
    }

    @Test
    void testSemGeneros() {
        Filme filme = new Filme();
        filme.setTitulo("Matrix " + System.nanoTime());
        filme.setGeneros(List.of()); // Lista vazia

        ActionResult result = action.execute(filme);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Selecione pelo menos um gênero", result.getMessage());
    }

    @Test
    void testFilmeDuplicado() {
        Filme filme = new Filme();
        filme.setTitulo("Duplicado " + System.nanoTime()); // Título único
        filme.setGeneros(List.of(new Genero("Ficção")));

        FilmeRepository.getInstance().add(filme); // Adiciona manualmente

        ActionResult result = action.execute(filme); // Tenta adicionar de novo

        assertFalse(result.isSuccess());
        assertEquals("Erro! Filme já existe na base de dados", result.getMessage());
    }

    @Test
    void testFilmeValido() {
        Filme filme = new Filme();
        filme.setTitulo("Filme Teste " + System.nanoTime());
        filme.setGeneros(List.of(new Genero("Drama"), new Genero("Histórico")));

        ActionResult result = action.execute(filme);

        assertTrue(result.isSuccess());
        assertEquals("Filme criado com sucesso", result.getMessage());
        assertTrue(FilmeRepository.getInstance().getItems().contains(filme));
    }
}

=========================

==========================
{src/tests/controller/action/filme/CreateFilmeValidationTest.java}
package tests.controller.action.filme;

import controller.action.filme.CreateFilmeValidation;
import controller.dataBase.FilmeRepository;
import model.Filme;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class CreateFilmeValidationTest {

    private CreateFilmeValidation validation;

    @BeforeEach
    void setUp() {
        validation = new CreateFilmeValidation();
    }

    @Test
    void testTituloVazio() {
        Filme filme = new Filme();
        filme.setTitulo("");
        filme.setGeneros(List.of(new Genero("Ação")));

        boolean isValid = validation.isValid(filme);

        assertFalse(isValid);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testSemGeneros() {
        Filme filme = new Filme();
        filme.setTitulo("Sem Genero");
        filme.setGeneros(List.of()); // Lista vazia

        boolean isValid = validation.isValid(filme);

        assertFalse(isValid);
        assertEquals("Erro! Selecione pelo menos um genero", validation.getErrorMessage());
    }

    @Test
    void testFilmeDuplicado() {
        Filme filme = new Filme();
        filme.setTitulo("Duplicado 123");
        filme.setGeneros(List.of(new Genero("Aventura")));

        FilmeRepository.getInstance().add(filme); // Adiciona na base antes

        boolean isValid = validation.isValid(filme);

        assertFalse(isValid);
        assertEquals("Erro! Filme ja existe na base de dados", validation.getErrorMessage());
    }

    @Test
    void testFilmeValido() {
        Filme filme = new Filme();
        filme.setTitulo("Valido 123 " + System.nanoTime());
        filme.setGeneros(List.of(new Genero("Fantasia")));

        boolean isValid = validation.isValid(filme);

        assertTrue(isValid);
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/action/filme/UpdateFilmeActionTest.java}
package tests.controller.action.filme;

import controller.action.filme.UpdateFilmeAction;
import controller.action.ActionResult;
import controller.action.filme.UpdateFilmeValidation;
import controller.dataBase.FilmeRepository;
import model.Filme;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class UpdateFilmeActionTest {

    private UpdateFilmeAction action;
    private UpdateFilmeValidation validation;

    @BeforeEach
    void setUp() {
        validation = new UpdateFilmeValidation();
        action = new UpdateFilmeAction(validation);
    }

    @Test
    void testFilmeAtualizadoComSucesso() {
        // Criando o filme e adicionando ao repositório antes da ação
        Filme filme = new Filme();
        filme.setTitulo("Filme Atualizado");
        filme.setGeneros(List.of(new Genero("Ação")));
        FilmeRepository.getInstance().add(filme);

        // Alterando os dados do filme para a atualização
        filme.setTitulo("Filme Atualizado - Novo Título");

        ActionResult result = action.execute(filme);

        assertTrue(result.isSuccess());
        assertEquals("Filme atualizado com sucesso", result.getMessage());

        // Verificando se o filme foi atualizado na base de dados
        Filme filmeAtualizado = FilmeRepository.getInstance().getItemById(filme.getId());
        assertNotNull(filmeAtualizado);
        assertEquals("Filme Atualizado - Novo Título", filmeAtualizado.getTitulo());
    }

    @Test
    void testFilmeComTituloVazio() {
        Filme filme = new Filme();
        filme.setTitulo("");
        filme.setGeneros(List.of(new Genero("Ação")));

        // Adicionando ao repositório antes de passar pela ação
        FilmeRepository.getInstance().add(filme);

        ActionResult result = action.execute(filme);

        assertFalse(result.isSuccess());
        assertEquals("Erro! titulo vazio", result.getMessage());
    }

    @Test
    void testFilmeComGeneroVazio() {
        Filme filme = new Filme();
        filme.setTitulo("Filme Sem Genero");
        filme.setGeneros(List.of());

        // Adicionando ao repositório antes de passar pela ação
        FilmeRepository.getInstance().add(filme);

        ActionResult result = action.execute(filme);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Selecione pelo menos um genero", result.getMessage());
    }

    @Test
    void testFilmeNaoExistente() {
        Filme filme = new Filme();
        filme.setTitulo("Filme Inexistente");
        filme.setGeneros(List.of(new Genero("Drama")));

        filme.setId(999); // Id fictício para um filme que não existe no repositório

        ActionResult result = action.execute(filme);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Filme não encontrado para atualização", result.getMessage());
    }
}

=========================

==========================
{src/tests/controller/action/filme/UpdateFilmeValidationTest.java}
package tests.controller.action.filme;

import controller.action.filme.UpdateFilmeValidation;
import model.Filme;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class UpdateFilmeValidationTest {

    private UpdateFilmeValidation validation;

    @BeforeEach
    void setUp() {
        validation = new UpdateFilmeValidation();
    }

    @Test
    void testTituloNulo() {
        Filme filme = new Filme();
        filme.setTitulo(null);
        filme.setGeneros(List.of(new Genero("Drama")));

        boolean isValid = validation.isValid(filme);

        assertFalse(isValid);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testTituloVazio() {
        Filme filme = new Filme();
        filme.setTitulo("");
        filme.setGeneros(List.of(new Genero("Comédia")));

        boolean isValid = validation.isValid(filme);

        assertFalse(isValid);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testSemGeneros() {
        Filme filme = new Filme();
        filme.setTitulo("Filme sem genero");
        filme.setGeneros(List.of());

        boolean isValid = validation.isValid(filme);

        assertFalse(isValid);
        assertEquals("Erro! Selecione pelo menos um genero", validation.getErrorMessage());
    }

    @Test
    void testFilmeValido() {
        Filme filme = new Filme();
        filme.setTitulo("Filme Atualizado");
        filme.setGeneros(List.of(new Genero("Ação")));

        boolean isValid = validation.isValid(filme);

        assertTrue(isValid);
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/action/genero/CreateGeneroActionTest.java}
package tests.controller.action.genero;

import controller.action.ActionResult;
import controller.action.genero.CreateGeneroAction;
import controller.action.genero.CreateGeneroValidation;
import controller.dataBase.GeneroRepository;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class CreateGeneroActionTest {

    private CreateGeneroAction action;

    @BeforeEach
    public void setUp() {
        action = new CreateGeneroAction(new CreateGeneroValidation());
        GeneroRepository.getInstance().getItems().clear();
    }

    @Test
    public void testCreateGeneroComDadosInvalidos() {
        Genero genero = new Genero(""); // nome inválido
        ActionResult result = action.execute(genero);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Nome do gênero não pode ser vazio", result.getMessage());
    }

    @Test
    public void testCreateGeneroComSucesso() {
        Genero genero = new Genero("Fantasia");
        ActionResult result = action.execute(genero);

        assertTrue(result.isSuccess());
        assertEquals("Gênero criado com sucesso", result.getMessage());
        assertTrue(GeneroRepository.getInstance().getItems().contains(genero));
    }

    @Test
    public void testCreateGeneroDuplicado() {
        Genero genero = new Genero("Romance");
        GeneroRepository.getInstance().add(genero);

        ActionResult result = action.execute(new Genero("Romance"));

        assertFalse(result.isSuccess());
        assertEquals("Erro! Gênero já existe na base de dados", result.getMessage());
    }
}

=========================

==========================
{src/tests/controller/action/genero/CreateGeneroValidationTest.java}
package tests.controller.action.genero;

import controller.action.genero.CreateGeneroValidation;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import controller.dataBase.GeneroRepository;

import static org.junit.jupiter.api.Assertions.*;

public class CreateGeneroValidationTest {

    private CreateGeneroValidation validation;

    @BeforeEach
    public void setUp() {
        validation = new CreateGeneroValidation();
        GeneroRepository.getInstance().getItems().clear(); // limpeza manual
    }

    @Test
    public void testNomeVazio() {
        Genero genero = new Genero("");
        assertFalse(validation.isValid(genero));
        assertEquals("Erro! Nome do gênero não pode ser vazio", validation.getErrorMessage());
    }

    @Test
    public void testNomeCurto() {
        Genero genero = new Genero("An");
        assertFalse(validation.isValid(genero));
        assertEquals("Erro! Nome do gênero deve ter pelo menos 3 caracteres", validation.getErrorMessage());
    }

    @Test
    public void testNomeLongo() {
        Genero genero = new Genero("A".repeat(51));
        assertFalse(validation.isValid(genero));
        assertEquals("Erro! Nome do gênero não pode ter mais de 50 caracteres", validation.getErrorMessage());
    }

    @Test
    public void testGeneroDuplicado() {
        Genero generoExistente = new Genero("Aventura");
        GeneroRepository.getInstance().add(generoExistente);

        Genero generoNovo = new Genero("Aventura");
        assertFalse(validation.isValid(generoNovo));
        assertEquals("Erro! Gênero já existe na base de dados", validation.getErrorMessage());
    }

    @Test
    public void testGeneroValido() {
        Genero genero = new Genero("Terror");
        assertTrue(validation.isValid(genero));
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/action/livro/CreateLivroActionTest.java}
package tests.controller.action.livro;

import controller.action.ActionResult;
import controller.action.livro.CreateLivroAction;
import controller.action.livro.CreateLivroValidation;
import controller.dataBase.LivroRepository;
import model.Genero;
import model.Livro;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class CreateLivroActionTest {

    private CreateLivroAction action;
    private LivroRepository repository;

    @BeforeEach
    void setUp() {
        repository = LivroRepository.getInstance();
        repository.getItems().clear(); // Limpa o repositório antes de cada teste
        action = new CreateLivroAction(new CreateLivroValidation());
    }

    @Test
    void testLivroComTituloVazio() {
        Livro livro = new Livro();
        livro.setTitulo("");
        livro.setIsbn("001");
        livro.setGeneros(List.of(new Genero("Drama")));

        ActionResult result = action.execute(livro);

        assertFalse(result.isSuccess());
        assertEquals("Erro! titulo vazio", result.getMessage());
    }

    @Test
    void testLivroComGenerosVazio() {
        Livro livro = new Livro();
        livro.setTitulo("Livro Teste");
        livro.setIsbn("002");
        livro.setGeneros(List.of());

        ActionResult result = action.execute(livro);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Selecione pelo menos um genero", result.getMessage());
    }

    @Test
    void testLivroComIsbnDuplicado() {
        Livro livroExistente = new Livro();
        livroExistente.setTitulo("Existente");
        livroExistente.setIsbn("003");
        livroExistente.setGeneros(List.of(new Genero("Fantasia")));
        repository.add(livroExistente);

        Livro livroNovo = new Livro();
        livroNovo.setTitulo("Novo");
        livroNovo.setIsbn("003"); // ISBN duplicado
        livroNovo.setGeneros(List.of(new Genero("Ficção")));

        ActionResult result = action.execute(livroNovo);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Já existe um livro com este ISBN na base de dados", result.getMessage());
    }

    @Test
    void testLivroValido() {
        Livro livro = new Livro();
        livro.setTitulo("Livro Válido");
        livro.setIsbn("004");
        livro.setGeneros(List.of(new Genero("Aventura")));

        ActionResult result = action.execute(livro);

        assertTrue(result.isSuccess());
        assertEquals("Livro criado com sucesso", result.getMessage());
        assertTrue(repository.getItems().contains(livro));
    }
}

=========================

==========================
{src/tests/controller/action/livro/CreateLivroValidationTest.java}
package tests.controller.action.livro;

import controller.action.livro.CreateLivroValidation;
import controller.dataBase.LivroRepository;
import model.Genero;
import model.Livro;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class CreateLivroValidationTest {

    private CreateLivroValidation validation;
    private LivroRepository repository;

    @BeforeEach
    void setUp() {
        validation = new CreateLivroValidation();
        repository = LivroRepository.getInstance();
        repository.getItems().clear(); // Garante que o repositório está limpo
    }

    @Test
    void testTituloVazio() {
        Livro livro = new Livro();
        livro.setTitulo("");
        livro.setIsbn("123");
        livro.setGeneros(List.of(new Genero("Ficção")));

        boolean isValid = validation.isValid(livro);

        assertFalse(isValid);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testGenerosVazios() {
        Livro livro = new Livro();
        livro.setTitulo("Livro Teste");
        livro.setIsbn("123");
        livro.setGeneros(List.of()); // Lista vazia

        boolean isValid = validation.isValid(livro);

        assertFalse(isValid);
        assertEquals("Erro! Selecione pelo menos um genero", validation.getErrorMessage());
    }

    @Test
    void testLivroComIsbnDuplicado() {
        Livro livroExistente = new Livro();
        livroExistente.setTitulo("Livro Existente");
        livroExistente.setIsbn("123");
        livroExistente.setGeneros(List.of(new Genero("Aventura")));
        repository.add(livroExistente); // Adiciona ao repositório

        Livro novoLivro = new Livro();
        novoLivro.setTitulo("Novo Livro");
        novoLivro.setIsbn("123"); // Mesmo ISBN
        novoLivro.setGeneros(List.of(new Genero("Ficção")));

        boolean isValid = validation.isValid(novoLivro);

        assertFalse(isValid);
        assertEquals("Erro! Já existe um livro com este ISBN na base de dados", validation.getErrorMessage());
    }

    @Test
    void testLivroValido() {
        Livro livro = new Livro();
        livro.setTitulo("Livro Válido");
        livro.setIsbn("456");
        livro.setGeneros(List.of(new Genero("História")));

        boolean isValid = validation.isValid(livro);

        assertTrue(isValid);
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/action/livro/UpdateSerieActionTest.java}
package tests.controller.action.livro;

import controller.action.ActionResult;
import controller.action.serie.UpdateSerieAction;
import controller.action.serie.UpdateSerieValidation;
import controller.dataBase.SerieRepository;
import model.Genero;
import model.Serie;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class UpdateSerieActionTest {

    private UpdateSerieAction action;
    private SerieRepository repository;

    @BeforeEach
    void setUp() {
        action = new UpdateSerieAction(new UpdateSerieValidation());
        repository = SerieRepository.getInstance();
        repository.getItems().clear();
    }

    @Test
    void testSerieComTituloVazio() {
        Serie serie = new Serie();
        serie.setTitulo("");
        serie.setGeneros(List.of(new Genero("Ação")));

        ActionResult result = action.execute(serie);

        assertFalse(result.isSuccess());
        assertEquals("Erro! título vazio", result.getMessage());
    }

    @Test
    void testSerieComGeneroVazio() {
        Serie serie = new Serie();
        serie.setTitulo("Breaking Bad");
        serie.setGeneros(List.of()); // Sem gêneros

        ActionResult result = action.execute(serie);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Selecione pelo menos um gênero", result.getMessage());
    }

    @Test
    void testUpdateSerieComSucesso() {
        Serie serie = new Serie();
        serie.setTitulo("Dark");
        serie.setGeneros(List.of(new Genero("Mistério")));

        // Adiciona uma versão anterior da série no repositório
        repository.add(serie);

        // Atualiza a série (mesmo título, outros gêneros)
        serie.setGeneros(List.of(new Genero("Ficção Científica")));

        ActionResult result = action.execute(serie);

        assertTrue(result.isSuccess());
        assertEquals("Serie atualizado com sucesso", result.getMessage());
        assertTrue(repository.getItems().contains(serie));
    }

    @Test
    void testErroAoAtualizarSerieInexistente() {
        Serie serie = new Serie();
        serie.setTitulo("Inexistente");
        serie.setGeneros(List.of(new Genero("Drama")));

        // Não adiciona no repositório — simula série inexistente

        ActionResult result = action.execute(serie);

        assertFalse(result.isSuccess());
        assertTrue(result.getMessage().startsWith("Erro!"));
    }
}

=========================

==========================
{src/tests/controller/action/livro/UpdateSerieValidationTest.java}
package tests.controller.action.livro;

import controller.action.serie.UpdateSerieValidation;
import model.Genero;
import model.Serie;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class UpdateSerieValidationTest {

    private UpdateSerieValidation validation;

    @BeforeEach
    void setUp() {
        validation = new UpdateSerieValidation();
    }

    @Test
    void testTituloVazio() {
        Serie serie = new Serie();
        serie.setTitulo(""); // título vazio
        serie.setGeneros(List.of(new Genero("Comédia")));

        boolean result = validation.isValid(serie);

        assertFalse(result);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testGenerosVazio() {
        Serie serie = new Serie();
        serie.setTitulo("The Office");
        serie.setGeneros(List.of()); // lista de gêneros vazia

        boolean result = validation.isValid(serie);

        assertFalse(result);
        assertEquals("Erro! Selecione pelo menos um genero", validation.getErrorMessage());
    }

    @Test
    void testSerieValida() {
        Serie serie = new Serie();
        serie.setTitulo("Stranger Things");
        serie.setGeneros(List.of(new Genero("Ficção")));

        boolean result = validation.isValid(serie);

        assertTrue(result);
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/action/serie/CreateSerieActionTest.java}
package tests.controller.action.serie;

import controller.action.serie.CreateSerieAction;
import controller.action.serie.CreateSerieValidation;
import controller.action.ActionResult;
import controller.dataBase.SerieRepository;
import model.Serie;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class CreateSerieActionTest {

    private CreateSerieAction action;
    private CreateSerieValidation validation;

    @BeforeEach
    void setUp() {
        validation = new CreateSerieValidation();
        action = new CreateSerieAction(validation);
    }

    @Test
    void testSerieCriadaComSucesso() {
        // Criando o filme e adicionando ao repositório
        Serie serie = new Serie();
        serie.setTitulo("Nova Série");
        serie.setGeneros(List.of(new Genero("Aventura")));

        // Verificando se o repositório está vazio antes de adicionar

        ActionResult result = action.execute(serie);

        // Verificando se a série foi criada com sucesso
        assertTrue(result.isSuccess());
        assertEquals("Série criada com sucesso", result.getMessage());

        // Verificando se a série foi adicionada ao repositório
        assertTrue(SerieRepository.getInstance().getItems().contains(serie));
    }

    @Test
    void testSerieComTituloVazio() {
        Serie serie = new Serie();
        serie.setTitulo("");
        serie.setGeneros(List.of(new Genero("Aventura")));

        ActionResult result = action.execute(serie);

        assertFalse(result.isSuccess());
        assertEquals("Erro! titulo vazio", result.getMessage());
    }

    @Test
    void testSerieComGeneroVazio() {
        Serie serie = new Serie();
        serie.setTitulo("Série Sem Gênero");
        serie.setGeneros(List.of());

        ActionResult result = action.execute(serie);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Selecione pelo menos um genero", result.getMessage());
    }

    @Test
    void testSerieJaExistente() {
        Serie serieExistente = new Serie();
        serieExistente.setTitulo("Série Existente");
        serieExistente.setGeneros(List.of(new Genero("Comédia")));
        SerieRepository.getInstance().add(serieExistente); // Adiciona no repositório

        Serie serieNova = new Serie();
        serieNova.setTitulo("Série Existente");
        serieNova.setGeneros(List.of(new Genero("Comédia"))); // Mesmo título e gênero

        ActionResult result = action.execute(serieNova);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Serie ja existe na base de dados", result.getMessage());
    }
}

=========================

==========================
{src/tests/controller/action/serie/CreateSerieValidationTest.java}
package tests.controller.action.serie;

import controller.action.serie.CreateSerieValidation;
import model.Serie;
import model.Genero;
import controller.dataBase.SerieRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class CreateSerieValidationTest {

    private CreateSerieValidation validation;

    @BeforeEach
    void setUp() {
        validation = new CreateSerieValidation();

        // Limpa o repositório manualmente antes de cada teste
        SerieRepository.getInstance().getItems().clear();  // Limpeza manual da lista de itens
    }

    @Test
    void testTituloVazio() {
        Serie serie = new Serie();
        serie.setTitulo("");  // Título vazio
        serie.setGeneros(List.of(new Genero("Aventura")));

        boolean isValid = validation.isValid(serie);

        assertFalse(isValid);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testGeneroVazio() {
        Serie serie = new Serie();
        serie.setTitulo("Série Sem Gênero");
        serie.setGeneros(List.of());  // Gêneros vazios

        boolean isValid = validation.isValid(serie);

        assertFalse(isValid);
        assertEquals("Erro! Selecione pelo menos um genero", validation.getErrorMessage());
    }

    @Test
    void testSerieJaExistenteNoRepositório() {
        // Adiciona uma série no repositório
        Serie serieExistente = new Serie();
        serieExistente.setTitulo("Série Existente");
        serieExistente.setGeneros(List.of(new Genero("Comédia")));
        SerieRepository.getInstance().add(serieExistente);

        // Tenta adicionar uma série com o mesmo título
        Serie serieDuplicada = new Serie();
        serieDuplicada.setTitulo("Série Existente");
        serieDuplicada.setGeneros(List.of(new Genero("Drama")));

        boolean isValid = validation.isValid(serieDuplicada);

        assertFalse(isValid);
        assertEquals("Erro! Serie ja existe na base de dados", validation.getErrorMessage());
    }

    @Test
    void testSerieValida() {
        Serie serie = new Serie();
        serie.setTitulo("Nova Série");
        serie.setGeneros(List.of(new Genero("Aventura")));

        boolean isValid = validation.isValid(serie);

        assertTrue(isValid);
    }
}

=========================

==========================
{src/tests/controller/action/serie/UpdateSerieActionTest.java}
package tests.controller.action.serie;

import controller.action.serie.UpdateSerieAction;
import controller.action.serie.UpdateSerieValidation;
import controller.dataBase.SerieRepository;
import model.Serie;
import model.Genero;
import controller.action.ActionResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class UpdateSerieActionTest {

    private UpdateSerieValidation validation;
    private UpdateSerieAction action;

    @BeforeEach
    void setUp() {
        validation = new UpdateSerieValidation();
        action = new UpdateSerieAction(validation);

        // Limpa o repositório antes de cada teste
        SerieRepository.getInstance().getItems().clear();
    }

    @Test
    void testUpdateSerieTituloVazio() {
        Serie serie = new Serie();
        serie.setTitulo("");  // Título vazio
        serie.setGeneros(List.of(new Genero("Aventura")));

        ActionResult result = action.execute(serie);

        assertFalse(result.isSuccess());
        assertEquals("Erro! titulo vazio", result.getMessage());
    }

    @Test
    void testUpdateSerieGeneroVazio() {
        Serie serie = new Serie();
        serie.setTitulo("Série Sem Gênero");
        serie.setGeneros(List.of());  // Gêneros vazios

        ActionResult result = action.execute(serie);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Selecione pelo menos um genero", result.getMessage());
    }

    @Test
    void testUpdateSerieValida() {
        // Adiciona uma série no repositório
        Serie serieExistente = new Serie();
        serieExistente.setTitulo("Série Existente");
        serieExistente.setGeneros(List.of(new Genero("Aventura")));
        SerieRepository.getInstance().add(serieExistente);

        // Atualiza a série
        serieExistente.setTitulo("Série Atualizada");
        serieExistente.setGeneros(List.of(new Genero("Comédia")));

        ActionResult result = action.execute(serieExistente);

        assertTrue(result.isSuccess());
        assertEquals("Serie atualizado com sucesso", result.getMessage());
    }

    @Test
    void testUpdateSerieNaoExistente() {
        Serie serieNaoExistente = new Serie();
        serieNaoExistente.setTitulo("Série Não Existente");
        serieNaoExistente.setGeneros(List.of(new Genero("Drama")));

        ActionResult result = action.execute(serieNaoExistente);

        assertFalse(result.isSuccess());
        assertEquals("Erro! Série não encontrada para atualização.", result.getMessage());
    }
}

=========================

==========================
{src/tests/controller/action/serie/UpdateSerieValidationTest.java}
package tests.controller.action.serie;

import controller.action.serie.UpdateSerieValidation;
import model.Genero;
import model.Serie;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class UpdateSerieValidationTest {

    private UpdateSerieValidation validation;

    @BeforeEach
    void setUp() {
        validation = new UpdateSerieValidation();
    }

    @Test
    void testTituloVazio() {
        Serie serie = new Serie();
        serie.setTitulo(""); // Título vazio
        serie.setGeneros(List.of(new Genero("Ação")));

        boolean isValid = validation.isValid(serie);

        assertFalse(isValid);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testTituloNulo() {
        Serie serie = new Serie();
        serie.setTitulo(null); // Título nulo
        serie.setGeneros(List.of(new Genero("Comédia")));

        boolean isValid = validation.isValid(serie);

        assertFalse(isValid);
        assertEquals("Erro! titulo vazio", validation.getErrorMessage());
    }

    @Test
    void testGenerosVazios() {
        Serie serie = new Serie();
        serie.setTitulo("Série Teste");
        serie.setGeneros(List.of()); // Nenhum gênero

        boolean isValid = validation.isValid(serie);

        assertFalse(isValid);
        assertEquals("Erro! Selecione pelo menos um genero", validation.getErrorMessage());
    }

    @Test
    void testSerieValida() {
        Serie serie = new Serie();
        serie.setTitulo("Série Válida");
        serie.setGeneros(List.of(new Genero("Drama")));

        boolean isValid = validation.isValid(serie);

        assertTrue(isValid);
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/action/temporada/CreateTemporadaActionTest.java}
package tests.controller.action.temporada;

import controller.action.ActionResult;
import controller.action.temporada.CreateTemporadaAction;
import controller.action.temporada.CreateTemporadaValidation;
import controller.dataBase.SerieRepository;
import model.Serie;
import model.Temporada;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class CreateTemporadaActionTest {

    private CreateTemporadaAction action;
    private Serie serie;

    @BeforeEach
    public void setUp() {
        action = new CreateTemporadaAction(new CreateTemporadaValidation());
        serie = new Serie();
        serie.setTitulo("Teste Série");
        SerieRepository.getInstance().getItems().clear(); // Limpar repositório
        SerieRepository.getInstance().add(serie); // Adiciona a série para garantir que ela exista
        action.setSuperModel(serie);
    }

    @Test
    public void testExecuteSemSuperModel() {
        CreateTemporadaAction actionSemSerie = new CreateTemporadaAction(new CreateTemporadaValidation());
        Temporada temporada = new Temporada();
        ActionResult result = actionSemSerie.execute(temporada);

        assertFalse(result.isSuccess());
        assertEquals("Set super model", result.getMessage());
    }

    @Test
    public void testExecuteComSucesso() {
        Temporada temporada = new Temporada();
        ActionResult result = action.execute(temporada);

        assertTrue(result.isSuccess());
        assertEquals("Temporada created successfully", result.getMessage());
        assertTrue(serie.getTemporadas().contains(temporada));
    }
}

=========================

==========================
{src/tests/controller/action/temporada/CreateTemporadaValidationTest.java}
package tests.controller.action.temporada;

import controller.action.temporada.CreateTemporadaValidation;
import model.Temporada;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class CreateTemporadaValidationTest {

    private CreateTemporadaValidation validation;

    @BeforeEach
    public void setUp() {
        validation = new CreateTemporadaValidation();
    }

    @Test
    public void testValidationAlwaysTrue() {
        Temporada temporada = new Temporada(); // pode ter campos nulos, pois isValid retorna true
        assertTrue(validation.isValid(temporada));
        assertNull(validation.getErrorMessage());
    }
}

=========================

==========================
{src/tests/controller/dataBase/FilmeRepositoryTest.java}
package tests.controller.dataBase;

import controller.dataBase.FilmeRepository;
import model.Filme;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class FilmeRepositoryTest {

    private FilmeRepository repository;

    @BeforeEach
    public void setUp() {
        repository = FilmeRepository.getInstance();
        repository.getItems().clear();
        repository.setFilmeId(0);
        // limpa antes de cada teste
    }

    @Test
    public void testAddFilme() {
        Filme filme = new Filme();
        filme.setTitulo("A Origem");
        repository.add(filme);

        List<Filme> filmes = repository.getItems();
        assertEquals(1, filmes.size());
        assertEquals("A Origem", filmes.get(0).getTitulo());
        assertEquals(0, filmes.get(0).getId()); // primeiro ID deve ser 0
    }

    @Test
    public void testGetItemById() {
        Filme filme = new Filme();
        filme.setTitulo("Interestelar");
        repository.add(filme);

        Filme encontrado = repository.getItemById(filme.getId());
        assertNotNull(encontrado);
        assertEquals("Interestelar", encontrado.getTitulo());

        Filme naoEncontrado = repository.getItemById(999);
        assertNull(naoEncontrado);
    }

    @Test
    public void testUpdateFilmeExistente() {
        Filme filme = new Filme();
        filme.setTitulo("Matrix");
        repository.add(filme);

        Filme atualizado = new Filme();
        atualizado.setTitulo("Matrix Reloaded");
        atualizado.setId(filme.getId());
        repository.update(atualizado);

        Filme resultado = repository.getItemById(filme.getId());
        assertEquals("Matrix Reloaded", resultado.getTitulo());
    }

    @Test
    public void testUpdateFilmeInexistente() {
        Filme filme = new Filme();
        filme.setTitulo("Filme inexistente");
        filme.setId(999);

        Exception exception = assertThrows(RuntimeException.class, () -> {
            repository.update(filme);
        });

        assertEquals("Filme não encontrado para atualização", exception.getMessage());
    }

    @Test
    public void testDeleteFilme() {
        Filme filme = new Filme();
        filme.setTitulo("O Senhor dos Anéis");
        repository.add(filme);

        assertEquals(1, repository.getItems().size());

        repository.delete(filme);

        assertEquals(0, repository.getItems().size());
    }

    @Test
    public void testDeleteFilmeInexistente() {
        Filme filme1 = new Filme();
        filme1.setTitulo("Shrek");
        repository.add(filme1);

        Filme filme2 = new Filme();
        filme2.setTitulo("Filme Inexistente");
        filme2.setId(999);
        repository.delete(filme2); // Não deve lançar erro

        assertEquals(1, repository.getItems().size()); // Ainda contém Shrek
    }
}

=========================

==========================
{src/tests/controller/dataBase/GeneroRepositoryTest.java}
package tests.controller.dataBase;

import controller.dataBase.GeneroRepository;
import model.Genero;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class GeneroRepositoryTest {

    private GeneroRepository repository;

    @BeforeEach
    public void setUp() {
        repository = GeneroRepository.getInstance();
        repository.getItems().clear();  // Resetar lista antes de cada teste
        repository.setGeneroId(0);      // Resetar contador de IDs
    }

    @Test
    public void testAddGenero() {
        Genero genero = new Genero("Ação");
        repository.add(genero);

        List<Genero> lista = repository.getItems();
        assertEquals(1, lista.size());
        assertEquals("Ação", lista.get(0).getNome());
        assertEquals(0, lista.get(0).getId()); // Primeiro ID
    }

    @Test
    public void testGetItemById() {
        Genero genero = new Genero("Comédia");
        repository.add(genero);

        Genero encontrado = repository.getItemById(genero.getId());
        assertNotNull(encontrado);
        assertEquals("Comédia", encontrado.getNome());

        Genero inexistente = repository.getItemById(999);
        assertNull(inexistente);
    }

    @Test
    public void testUpdateGeneroExistente() {
        Genero genero = new Genero("Drama");
        repository.add(genero);

        Genero atualizado = new Genero("Drama Pesado");
        atualizado.setId(genero.getId());
        repository.update(atualizado);

        Genero resultado = repository.getItemById(genero.getId());
        assertEquals("Drama Pesado", resultado.getNome());
    }

    @Test
    public void testUpdateGeneroInexistente() {
        Genero genero = new Genero("Ficção");
        genero.setId(999);

        Exception e = assertThrows(RuntimeException.class, () -> {
            repository.update(genero);
        });

        assertEquals("Genero não encontrado para atualização", e.getMessage());
    }

    @Test
    public void testDeleteGenero() {
        Genero genero = new Genero("Suspense");
        repository.add(genero);
        assertEquals(1, repository.getItems().size());

        repository.delete(genero);
        assertEquals(0, repository.getItems().size());
    }

    @Test
    public void testDeleteGeneroInexistente() {
        Genero genero1 = new Genero("Terror");
        repository.add(genero1);

        Genero genero2 = new Genero("Não Existe");
        genero2.setId(999);
        repository.delete(genero2);  // Não deve lançar exceção

        assertEquals(1, repository.getItems().size());
    }

    @Test
    public void testSetGeneroId() {
        Genero genero = new Genero("Musical");
        repository.setGeneroId(100);
        repository.add(genero);
        assertEquals(100, genero.getId());
    }
}

=========================

==========================
{src/tests/controller/dataBase/LivroRepositoryTest.java}
package tests.controller.dataBase;

import controller.dataBase.LivroRepository;
import model.Livro;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class LivroRepositoryTest {

    private LivroRepository repository;

    @BeforeEach
    public void setUp() {
        repository = LivroRepository.getInstance();
        repository.getItems().clear();  // Limpa os dados antes de cada teste
        repository.setLivroId(0);       // Reinicia o contador de ID
    }

    @Test
    public void testAddLivro() {
        Livro livro = new Livro();
        livro.setTitulo("O Senhor dos Anéis");
        repository.add(livro);

        List<Livro> livros = repository.getItems();
        assertEquals(1, livros.size());
        assertEquals("O Senhor dos Anéis", livros.get(0).getTitulo());
        assertEquals(0, livros.get(0).getId());
    }

    @Test
    public void testGetItemById() {
        Livro livro = new Livro();
        livro.setTitulo("1984");
        repository.add(livro);

        Livro encontrado = repository.getItemById(livro.getId());
        assertNotNull(encontrado);
        assertEquals("1984", encontrado.getTitulo());

        Livro inexistente = repository.getItemById(999);
        assertNull(inexistente);
    }

    @Test
    public void testUpdateLivroExistente() {
        Livro livro = new Livro();
        livro.setTitulo("O Hobbit");
        repository.add(livro);

        Livro atualizado = new Livro();
        atualizado.setTitulo("O Hobbit - Edição Especial");
        atualizado.setId(livro.getId());
        repository.update(atualizado);

        Livro resultado = repository.getItemById(livro.getId());
        assertEquals("O Hobbit - Edição Especial", resultado.getTitulo());
    }

    @Test
    public void testUpdateLivroInexistente() {
        Livro livro = new Livro();
        livro.setTitulo("A Metamorfose");
        livro.setId(999);

        Exception e = assertThrows(RuntimeException.class, () -> {
            repository.update(livro);
        });

        assertEquals("Livro não encontrado para atualização.", e.getMessage());
    }

    @Test
    public void testDeleteLivro() {
        Livro livro = new Livro();
        livro.setTitulo("Dom Casmurro");
        repository.add(livro);
        assertEquals(1, repository.getItems().size());

        repository.delete(livro);
        assertEquals(0, repository.getItems().size());
    }

    @Test
    public void testDeleteLivroInexistente() {
        Livro livro1 = new Livro();
        livro1.setTitulo("A Moreninha");
        repository.add(livro1);

        Livro livro2 = new Livro();
        livro2.setTitulo("Inexistente");
        livro2.setId(999);
        repository.delete(livro2); // Não lança exceção

        assertEquals(1, repository.getItems().size());
    }

    @Test
    public void testSetLivroId() {
        Livro livro = new Livro();
        livro.setTitulo("A Revolução dos Bichos");
        repository.setLivroId(50);
        repository.add(livro);

        assertEquals(50, livro.getId());
    }
}

=========================

==========================
{src/tests/controller/dataBase/SerieRepositoryTest.java}
package tests.controller.dataBase;

import controller.dataBase.SerieRepository;
import model.Serie;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class SerieRepositoryTest {

    private SerieRepository repository;

    @BeforeEach
    public void setUp() {
        repository = SerieRepository.getInstance();
        repository.getItems().clear();  // Limpa antes de cada teste
        repository.setSerieId(0);       // Reinicia o contador de ID
    }

    @Test
    public void testAddSerie() {
        Serie serie = new Serie();
        serie.setTitulo("Breaking Bad");
        repository.add(serie);

        List<Serie> series = repository.getItems();
        assertEquals(1, series.size());
        assertEquals("Breaking Bad", series.get(0).getTitulo());
        assertEquals(0, series.get(0).getId());
    }

    @Test
    public void testGetItemById() {
        Serie serie = new Serie();
        serie.setTitulo("Stranger Things");
        repository.add(serie);

        Serie encontrada = repository.getItemById(serie.getId());
        assertNotNull(encontrada);
        assertEquals("Stranger Things", encontrada.getTitulo());

        Serie inexistente = repository.getItemById(999);
        assertNull(inexistente);
    }

    @Test
    public void testUpdateSerieExistente() {
        Serie serie = new Serie();
        serie.setTitulo("Dark");
        repository.add(serie);

        Serie atualizada = new Serie();
        atualizada.setTitulo("Dark - Final");
        atualizada.setId(serie.getId());
        repository.update(atualizada);

        Serie resultado = repository.getItemById(serie.getId());
        assertEquals("Dark - Final", resultado.getTitulo());
    }
}

=========================

==========================
{src/tests/mocks/MockFilme.java}
package tests.mocks;

import controller.action.filme.CreateFilmeAction;
import controller.action.filme.CreateFilmeValidation;
import controller.dataBase.GeneroRepository;
import model.Filme;
import model.Genero;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

public class MockFilme {
    public static void rodar() {
        List<Genero> g = GeneroRepository.getInstance().getItems();
        if (g.isEmpty()) {
            MockGenero.rodar();
        }
        CreateFilmeAction action = new CreateFilmeAction(new CreateFilmeValidation());

        List<Filme> filmes = Arrays.asList(
                new Filme("Avengers", LocalDateTime.of(2019, 4, 26, 0, 0), true, g.subList(0, 2), "Avengers Ultimato", "Prime Video",
                        Arrays.asList("Robert Downey Jr.", "Scarlett Johansson"), "Alguém", 120, "Filme muito bom"),

                new Filme("Her", LocalDateTime.of(2013, 12, 18, 0, 0), false, g.subList(3, 4), "Homem se apaixona por IA", "HBO Max",
                        Arrays.asList("Joaquin Phoenix", "Scarlett Johansson"), "Spike Jonze", 126, "Drama romântico"),

                new Filme("Corra!", LocalDateTime.of(2017, 2, 24, 0, 0), false, g.subList(4, 6), "Suspense psicológico", "Netflix",
                        Arrays.asList("Daniel Kaluuya", "Allison Williams"), "Jordan Peele", 104, "Terror e crítica social"),

                new Filme("Toy Story", LocalDateTime.of(1995, 11, 22, 0, 0), false, g.subList(8, 9), "Brinquedos vivos", "Disney+",
                        Arrays.asList("Tom Hanks", "Tim Allen"), "Pixar", 81, "Animação clássica"),

                new Filme("O Jogo da Imitação", LocalDateTime.of(2014, 11, 28, 0, 0), false, g.subList(5, 7), "Alan Turing", "Globoplay",
                        Arrays.asList("Benedict Cumberbatch", "Keira Knightley"), "Morten Tyldum", 113, "Drama histórico"),

                new Filme("Interestelar", LocalDateTime.of(2014, 11, 7, 0, 0), false, g.subList(2, 3), "Viagem no tempo e espaço", "Netflix",
                        Arrays.asList("Matthew McConaughey", "Anne Hathaway"), "Christopher Nolan", 169, "Ficção científica épica"),

                new Filme("O Labirinto do Fauno", LocalDateTime.of(2006, 10, 11, 0, 0), false, g.subList(1, 2), "Fantasia sombria na guerra civil espanhola", "HBO Max",
                        Arrays.asList("Ivana Baquero", "Sergi López"), "Guillermo del Toro", 118, "Conto sombrio e mágico"),

                new Filme("Senna", LocalDateTime.of(2010, 10, 7, 0, 0), false, g.subList(9, 10), "Documentário sobre Ayrton Senna", "Amazon Prime",
                        Arrays.asList("Ayrton Senna", "Alain Prost"), "Asif Kapadia", 106, "Documentário emocionante sobre um ídolo")
        );

        for (Filme f : filmes) {
            action.execute(f);
        }
    }
}

=========================

==========================
{src/tests/mocks/MockGenero.java}
package tests.mocks;

import controller.action.genero.CreateGeneroAction;
import controller.action.genero.CreateGeneroValidation;
import model.Genero;

public class MockGenero {
    public static void rodar() {
        String[] nomesGeneros = {
                "Ficção Científica",
                "Fantasia",
                "Romance",
                "Mistério",
                "Biografia",
                "História",
                "Tecnologia",
                "Autoajuda",
                "Aventura",
                "Terror"
        };

        CreateGeneroAction action = new CreateGeneroAction(new CreateGeneroValidation());

        for (String nome : nomesGeneros) {
            action.execute(new Genero(nome));
        }
    }
}

=========================

==========================
{src/tests/mocks/MockLivro.java}
package tests.mocks;

import controller.action.livro.CreateLivroAction;
import controller.action.livro.CreateLivroValidation;
import controller.dataBase.GeneroRepository;
import model.Genero;
import model.Livro;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

public class MockLivro {
    public static void rodar() {
        List<Genero> g = GeneroRepository.getInstance().getItems();
        if (g.isEmpty()) {
            MockGenero.rodar();
        }

        CreateLivroAction action = new CreateLivroAction(new CreateLivroValidation());

        List<Livro> livros = Arrays.asList(
                new Livro("Duna", LocalDateTime.of(1965, 8, 1, 0, 0), true, g.subList(0, 1), "Frank Herbert", "Aleph", true, "9788576573134"),
                new Livro("Harry Potter e a Pedra Filosofal", LocalDateTime.of(1997, 6, 26, 0, 0), true, g.subList(1, 2), "J.K. Rowling", "Rocco", true, "9788532511010"),
                new Livro("Orgulho e Preconceito", LocalDateTime.of(1813, 1, 28, 0, 0), false, g.subList(2, 3), "Jane Austen", "Penguin", false, "9780141439518"),
                new Livro("O Código Da Vinci", LocalDateTime.of(2003, 3, 18, 0, 0), true, g.subList(3, 4), "Dan Brown", "Sextante", false, "9788575421139"),
                new Livro("Steve Jobs", LocalDateTime.of(2011, 10, 24, 0, 0), false, g.subList(4, 5), "Walter Isaacson", "Companhia das Letras", true, "9788535920413"),
                new Livro("Sapiens", LocalDateTime.of(2011, 6, 4, 0, 0), false, g.subList(5, 6), "Yuval Noah Harari", "L&PM", false, "9788578270697"),
                new Livro("Clean Code", LocalDateTime.of(2008, 8, 1, 0, 0), true, g.subList(6, 7), "Robert C. Martin", "Alta Books", true, "9788576082674"),
                new Livro("O Poder do Hábito", LocalDateTime.of(2012, 2, 28, 0, 0), false, g.subList(7, 8), "Charles Duhigg", "Objetiva", true, "9788539004119"),
                new Livro("A Ilha do Tesouro", LocalDateTime.of(1883, 11, 14, 0, 0), false, g.subList(8, 9), "Robert Louis Stevenson", "Zahar", false, "9788537811061"),
                new Livro("It: A Coisa", LocalDateTime.of(1986, 9, 15, 0, 0), false, g.subList(9, 10), "Stephen King", "Suma", false, "9788544105080")
        );

        for (Livro livro : livros) {
            action.execute(livro);
        }
    }
}

=========================

==========================
{src/tests/mocks/MockSerie.java}
package tests.mocks;

import controller.action.serie.CreateSerieAction;
import controller.action.serie.CreateSerieValidation;
import controller.action.serie.UpdateSerieAction;
import controller.action.serie.UpdateSerieValidation;
import controller.dataBase.GeneroRepository;
import model.Genero;
import model.Serie;
import model.Temporada;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

public class MockSerie {
    public static void rodar() {
        List<Genero> generos = GeneroRepository.getInstance().getItems();
        if (generos.isEmpty()) {
            MockGenero.rodar();
            generos = GeneroRepository.getInstance().getItems();
        }

        CreateSerieAction createSerieAction = new CreateSerieAction(new CreateSerieValidation());
        UpdateSerieAction updateSerieAction = new UpdateSerieAction(new UpdateSerieValidation());

        Serie breakingBad = new Serie("Breaking Bad", LocalDateTime.of(2008, 1, 20, 0, 0), true, generos.subList(0, 2),
                "Breaking Bad - Química do mal", "AMC", Arrays.asList("Bryan Cranston", "Aaron Paul"), LocalDateTime.of(2013, 9, 29, 0, 0));
        Serie strangerThings = new Serie("Stranger Things", LocalDateTime.of(2016, 7, 15, 0, 0), false, generos.subList(1, 3),
                "Stranger Things - Mundo invertido", "Netflix", Arrays.asList("Millie Bobby Brown", "David Harbour"), LocalDateTime.of(2025, 1, 1, 0, 0));
        Serie theOffice = new Serie("The Office", LocalDateTime.of(2005, 3, 24, 0, 0), true, generos.subList(0, 2),
                "The Office - Escritório americano", "NBC", Arrays.asList("Steve Carell", "John Krasinski"), LocalDateTime.of(2013, 5, 16, 0, 0));
        Serie gameOfThrones = new Serie("Game of Thrones", LocalDateTime.of(2011, 4, 17, 0, 0), true, generos.subList(0, 2),
                "Game of Thrones - A Guerra dos Tronos", "HBO", Arrays.asList("Emilia Clarke", "Kit Harington"), LocalDateTime.of(2019, 5, 19, 0, 0));
        Serie theWitcher = new Serie("The Witcher", LocalDateTime.of(2019, 12, 20, 0, 0), false, generos.subList(0, 2),
                "The Witcher - Geralt de Rívia", "Netflix", Arrays.asList("Henry Cavill", "Freya Allan"), LocalDateTime.of(2025, 1, 1, 0, 0));
        Serie dark = new Serie("Dark", LocalDateTime.of(2017, 12, 1, 0, 0), true, generos.subList(0, 2),
                "Dark - O ciclo eterno", "Netflix", Arrays.asList("Louis Hofmann", "Maja Schöne"), LocalDateTime.of(2020, 6, 27, 0, 0));
        Serie sherlock = new Serie("Sherlock", LocalDateTime.of(2010, 7, 25, 0, 0), true, generos.subList(0, 2),
                "Sherlock Holmes - BBC", "BBC iPlayer", Arrays.asList("Benedict Cumberbatch", "Martin Freeman"), LocalDateTime.of(2017, 1, 1, 0, 0));
        Serie chernobyl = new Serie("Chernobyl", LocalDateTime.of(2019, 5, 6, 0, 0), true, generos.subList(1, 3),
                "Chernobyl - HBO Minissérie", "HBO Max", Arrays.asList("Jared Harris", "Stellan Skarsgård"), LocalDateTime.of(2019, 5, 6, 0, 0));

        List<Serie> series = Arrays.asList(breakingBad, strangerThings, theOffice, gameOfThrones, theWitcher, dark, sherlock, chernobyl);

        for (Serie serie : series) {
            createSerieAction.execute(serie); // Criar série sem temporadas
        }

        // Agora adiciona as temporadas
        breakingBad.setTemporadas(Arrays.asList(
                new Temporada(7, LocalDateTime.of(2008, 1, 20, 0, 0)),
                new Temporada(13, LocalDateTime.of(2009, 3, 8, 0, 0)),
                new Temporada(13, LocalDateTime.of(2010, 3, 21, 0, 0)),
                new Temporada(13, LocalDateTime.of(2011, 7, 17, 0, 0)),
                new Temporada(16, LocalDateTime.of(2012, 7, 15, 0, 0))
        ));

        strangerThings.setTemporadas(Arrays.asList(
                new Temporada(8, LocalDateTime.of(2016, 7, 15, 0, 0)),
                new Temporada(9, LocalDateTime.of(2017, 10, 27, 0, 0)),
                new Temporada(8, LocalDateTime.of(2019, 7, 4, 0, 0)),
                new Temporada(9, LocalDateTime.of(2022, 5, 27, 0, 0))
        ));

        theOffice.setTemporadas(Arrays.asList(
                new Temporada(6, LocalDateTime.of(2005, 3, 24, 0, 0)),
                new Temporada(22, LocalDateTime.of(2006, 9, 21, 0, 0)),
                new Temporada(23, LocalDateTime.of(2007, 9, 27, 0, 0)),
                new Temporada(14, LocalDateTime.of(2008, 9, 25, 0, 0)),
                new Temporada(28, LocalDateTime.of(2009, 9, 17, 0, 0)),
                new Temporada(26, LocalDateTime.of(2010, 9, 23, 0, 0)),
                new Temporada(24, LocalDateTime.of(2011, 9, 22, 0, 0)),
                new Temporada(24, LocalDateTime.of(2012, 9, 20, 0, 0)),
                new Temporada(23, LocalDateTime.of(2013, 1, 10, 0, 0))
        ));

        gameOfThrones.setTemporadas(Arrays.asList(
                new Temporada(10, LocalDateTime.of(2011, 4, 17, 0, 0)),
                new Temporada(10, LocalDateTime.of(2012, 4, 1, 0, 0)),
                new Temporada(10, LocalDateTime.of(2013, 3, 31, 0, 0)),
                new Temporada(10, LocalDateTime.of(2014, 4, 6, 0, 0)),
                new Temporada(10, LocalDateTime.of(2015, 4, 12, 0, 0)),
                new Temporada(10, LocalDateTime.of(2016, 4, 24, 0, 0)),
                new Temporada(7, LocalDateTime.of(2017, 7, 16, 0, 0)),
                new Temporada(6, LocalDateTime.of(2019, 4, 14, 0, 0))
        ));

        theWitcher.setTemporadas(Arrays.asList(
                new Temporada(8, LocalDateTime.of(2019, 12, 20, 0, 0)),
                new Temporada(8, LocalDateTime.of(2021, 12, 17, 0, 0)),
                new Temporada(8, LocalDateTime.of(2023, 6, 29, 0, 0))
        ));

        dark.setTemporadas(Arrays.asList(
                new Temporada(10, LocalDateTime.of(2017, 12, 1, 0, 0)),
                new Temporada(8, LocalDateTime.of(2019, 6, 21, 0, 0)),
                new Temporada(8, LocalDateTime.of(2020, 6, 27, 0, 0))
        ));

        sherlock.setTemporadas(Arrays.asList(
                new Temporada(3, LocalDateTime.of(2010, 7, 25, 0, 0)),
                new Temporada(3, LocalDateTime.of(2012, 1, 1, 0, 0)),
                new Temporada(3, LocalDateTime.of(2014, 1, 1, 0, 0)),
                new Temporada(4, LocalDateTime.of(2017, 1, 1, 0, 0))
        ));

        chernobyl.setTemporadas(Arrays.asList(
                new Temporada(5, LocalDateTime.of(2019, 5, 6, 0, 0))
        ));

        // Atualizar as séries com temporadas
        for (Serie serie : series) {
            updateSerieAction.execute(serie);
        }
    }
}

=========================

==========================
{src/tests/model/AvaliacaoTest.java}
package tests.model;

import model.Avaliacao;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.assertEquals;

class AvaliacaoTest {

    @Test
    void testConstrutorEGetters() {
        LocalDateTime dataAvaliacao = LocalDateTime.of(2022, 5, 1, 10, 30);
        LocalDate dataConsumo = LocalDate.of(2022, 4, 20);
        Avaliacao avaliacao = new Avaliacao(dataAvaliacao, 4, "Muito bom", dataConsumo);

        assertEquals(dataAvaliacao, avaliacao.getDataAvaliacao());
        assertEquals(4, avaliacao.getPontuacao());
        assertEquals("Muito bom", avaliacao.getReview());
        assertEquals(dataConsumo, avaliacao.getDataConsumo());
    }

    @Test
    void testSetters() {
        Avaliacao avaliacao = new Avaliacao(
                LocalDateTime.of(2022, 5, 1, 10, 30),
                3,
                "Razoável",
                LocalDate.of(2022, 4, 20)
        );

        avaliacao.setPontuacao(5);
        avaliacao.setReview("Excelente!");
        avaliacao.setDataAvaliacao(LocalDateTime.of(2023, 6, 15, 14, 0));
        avaliacao.setDataConsumo(LocalDate.of(2023, 6, 1));

        assertEquals(5, avaliacao.getPontuacao());
        assertEquals("Excelente!", avaliacao.getReview());
        assertEquals(LocalDateTime.of(2023, 6, 15, 14, 0), avaliacao.getDataAvaliacao());
        assertEquals(LocalDate.of(2023, 6, 1), avaliacao.getDataConsumo());
    }

}

=========================

==========================
{src/tests/model/FilmeTest.java}
package tests.model;

import model.*;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

class FilmeTest {

    @Test
    void testConstrutorEGetters() {
        LocalDateTime dataLancamento = LocalDateTime.of(2021, 7, 10, 18, 30);
        Genero genero = new Genero("Ação");
        Avaliacao avaliacao = new Avaliacao(LocalDateTime.now(), 5, "Ótimo filme!", LocalDate.of(2021, 7, 11));

        Filme filme = new Filme("Vingadores: Ultimato", dataLancamento, true, Arrays.asList(genero),
                "Avengers: Endgame", "Disney+", Arrays.asList("Robert Downey Jr.", "Chris Evans"),
                "Anthony Russo", 181, "Roteiro maravilhoso");

        filme.avaliar(avaliacao);

        // Testando os valores dos atributos
        assertEquals("Vingadores: Ultimato", filme.getTitulo());
        assertEquals("Avengers: Endgame", filme.getTituloOriginal());
        assertEquals(dataLancamento, filme.getDataLancamento());
        assertTrue(filme.isConsumido());
        assertEquals(1, filme.getGeneros().size());
        assertEquals("Ação", filme.getGeneros().get(0).getNome());
        assertEquals("Disney+", filme.getLocalDisponivel());
        assertEquals(181, filme.getDuracao());
        assertEquals("Anthony Russo", filme.getDirecao());
        assertEquals("Roteiro maravilhoso", filme.getRoteiro());

        // Testando avaliações
        assertEquals(5, filme.getPontuacao());
        assertEquals(1, filme.getAvaliacoes().size());
    }

    @Test
    void testSetters() {
        Filme filme = new Filme();

        filme.setTitulo("Batman: O Cavaleiro das Trevas");
        filme.setDuracao(152);
        filme.setDirecao("Christopher Nolan");
        filme.setRoteiro("Roteiro sombroso e envolvente");

        assertEquals("Batman: O Cavaleiro das Trevas", filme.getTitulo());
        assertEquals(152, filme.getDuracao());
        assertEquals("Christopher Nolan", filme.getDirecao());
        assertEquals("Roteiro sombroso e envolvente", filme.getRoteiro());
    }

}

=========================

==========================
{src/tests/model/GeneroTest.java}
package tests.model;

import model.Genero;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class GeneroTest {

    @Test
    void testConstrutorEGetNome() {
        Genero genero = new Genero("Ação");
        assertEquals("Ação", genero.getNome());
    }

    @Test
    void testToStringRetornaNome() {
        Genero genero = new Genero("Comédia");
        assertEquals("Comédia", genero.toString());
    }

    @Test
    void testSetAndGetId() {
        Genero genero = new Genero("Drama");
        genero.setId(42);
        assertEquals(42, genero.getId());
    }
}

=========================

==========================
{src/tests/model/LivroTest.java}
package tests.model;

import model.*;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

class LivroTest {

    @Test
    void testConstrutorEGetters() {
        LocalDateTime dataLancamento = LocalDateTime.of(2021, 5, 15, 10, 0);
        Genero genero = new Genero("Ficção Científica");
        Avaliacao avaliacao = new Avaliacao(LocalDateTime.now(), 4, "Interessante e provocante!", LocalDate.of(2021, 5, 16));

        Livro livro = new Livro("Duna", dataLancamento, true, Arrays.asList(genero),
                "Frank Herbert", "Editora Aleph", true, "978-8539501077");

        livro.avaliar(avaliacao);

        // Testando os valores dos atributos
        assertEquals("Duna", livro.getTitulo());
        assertEquals("Frank Herbert", livro.getAutor());
        assertEquals("Editora Aleph", livro.getEditora());
        assertTrue(livro.isPossui());
        assertEquals("978-8539501077", livro.getIsbn());
        assertEquals(1, livro.getGeneros().size());
        assertEquals("Ficção Científica", livro.getGeneros().get(0).getNome());

        // Testando avaliações
        assertEquals(4, livro.getPontuacao());
        assertEquals(1, livro.getAvaliacoes().size());
    }

    @Test
    void testSetters() {
        Livro livro = new Livro();

        livro.setTitulo("O Senhor dos Anéis");
        livro.setAutor("J.R.R. Tolkien");
        livro.setEditora("HarperCollins");
        livro.setPossui(true);
        livro.setIsbn("978-0261103573");

        assertEquals("O Senhor dos Anéis", livro.getTitulo());
        assertEquals("J.R.R. Tolkien", livro.getAutor());
        assertEquals("HarperCollins", livro.getEditora());
        assertTrue(livro.isPossui());
        assertEquals("978-0261103573", livro.getIsbn());
    }

    @Test
    void testAvaliar() {
        Livro livro = new Livro("O Hobbit", LocalDateTime.of(2018, 4, 12, 15, 30), true,
                Arrays.asList(new Genero("Aventura")), "J.R.R. Tolkien", "HarperCollins", true, "978-0261103566");

        Avaliacao avaliacao1 = new Avaliacao(LocalDateTime.now(), 5, "Excelente história!", LocalDate.of(2018, 4, 12));
        Avaliacao avaliacao2 = new Avaliacao(LocalDateTime.now().minusDays(1), 4, "Bom livro, mas com alguns pontos fracos.", LocalDate.of(2018, 4, 10));

        livro.avaliar(avaliacao1);
        livro.avaliar(avaliacao2);

        assertEquals(5, livro.getPontuacao()); // Deve retornar a avaliação mais recente
        assertEquals(2, livro.getAvaliacoes().size());
    }
}

=========================

==========================
{src/tests/model/TemporadaTest.java}
package tests.model;

import model.*;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.time.LocalDateTime;


import static org.junit.jupiter.api.Assertions.*;

class TemporadaTest {

    @Test
    void testConstrutorEGetters() {
        LocalDateTime ano = LocalDateTime.of(2021, 9, 1, 0, 0);
        Avaliacao avaliacao = new Avaliacao(LocalDateTime.now(), 4, "Boa temporada, mas poderia ter mais ação!", LocalDate.of(2021, 9, 1));

        Temporada temporada = new Temporada(10, ano);
        temporada.setId(1);
        temporada.setSerieId(101);
        temporada.avaliar(avaliacao);

        // Testando os valores dos atributos
        assertEquals(1, temporada.getId());
        assertEquals(101, temporada.getSerieId());
        assertEquals(10, temporada.getqEpisodios());
        assertEquals(ano, temporada.getAno());
        assertEquals(4, temporada.getPontuacao());  // Última avaliação
        assertEquals(1, temporada.getAvaliacoes().size());
    }

    @Test
    void testSetters() {
        Temporada temporada = new Temporada(12, LocalDateTime.of(2022, 5, 1, 0, 0));

        temporada.setId(2);
        temporada.setSerieId(202);
        temporada.setAno(LocalDateTime.of(2023, 6, 15, 0, 0));
        temporada.setqEpisodios(15);

        assertEquals(2, temporada.getId());
        assertEquals(202, temporada.getSerieId());
        assertEquals(15, temporada.getqEpisodios());
        assertEquals(LocalDateTime.of(2023, 6, 15, 0, 0), temporada.getAno());
    }

    @Test
    void testAvaliar() {
        Temporada temporada = new Temporada(8, LocalDateTime.of(2020, 11, 1, 0, 0));
        Avaliacao avaliacao1 = new Avaliacao(LocalDateTime.now(), 3, "Boa, mas alguns episódios são arrastados.", LocalDate.of(2020, 11, 2));
        Avaliacao avaliacao2 = new Avaliacao(LocalDateTime.now().minusDays(1), 4, "Ótima temporada, gostei muito!", LocalDate.of(2020, 11, 1));

        temporada.avaliar(avaliacao1);
        temporada.avaliar(avaliacao2);

        assertEquals(3, temporada.getPontuacao()); // Deve retornar a avaliação mais recente
        assertEquals(2, temporada.getAvaliacoes().size());
    }

    @Test
    void testPontuacaoComAvaliacoes() {
        Temporada temporada = new Temporada(10, LocalDateTime.of(2021, 3, 1, 0, 0));
        Avaliacao avaliacao1 = new Avaliacao(LocalDateTime.now(), 5, "Excelente temporada!", LocalDate.of(2021, 3, 1));
        Avaliacao avaliacao2 = new Avaliacao(LocalDateTime.now().minusDays(2), 3, "Pode melhorar.", LocalDate.of(2021, 2, 28));

        temporada.avaliar(avaliacao1);
        temporada.avaliar(avaliacao2);

        // Testando a pontuação mais recente
        assertEquals(5, temporada.getPontuacao()); // A avaliação mais recente deve ser usada
    }

    @Test
    void testAvaliarComListaVazia() {
        Temporada temporada = new Temporada(5, LocalDateTime.of(2022, 7, 15, 0, 0));

        // Testa a pontuação quando não há avaliações
        assertEquals(0, temporada.getPontuacao());
        assertTrue(temporada.getAvaliacoes().isEmpty());
    }
}

=========================

==========================
{src/view/ListGridMedia.java}
package view;

import model.Media;

import java.util.List;

/**
 * Classe responsável por exibir uma lista de mídias (como filmes ou livros) em formato de tabela no terminal.
 * Cada linha da tabela exibe informações sobre uma mídia, como título, gênero, ano, tipo e pontuação.
 */
public class ListGridMedia {

    /**
     * Exibe a lista de mídias em formato de tabela no terminal.
     * A tabela é organizada em colunas com informações sobre a mídia, como título, gênero, ano, tipo e pontuação.
     *
     * @param medias Lista de mídias a ser exibida na tabela.
     */
    public void draw(List<Media> medias) {
        int colSeletor = 8;   // Tamanho da coluna para o seletor (índice)
        int colTitulo = 20;   // Tamanho da coluna para o título da mídia
        int colGenero = 20;   // Tamanho da coluna para o gênero
        int colAno = 6;       // Tamanho da coluna para o ano
        int colTipo = 20;     // Tamanho da coluna para o tipo de mídia
        int colPontuacao = 10; // Tamanho da coluna para a pontuação

        // Imprime linha superior
        printLinha(colSeletor, colTitulo, colGenero, colAno, colTipo, colPontuacao);

        // Cabeçalho da tabela
        System.out.printf("| %-"+colSeletor+"s | %-"+colTitulo+"s | %-"+colGenero+"s | %-"+colAno+"s | %-"+colTipo+"s | %-"+colPontuacao+"s |%n",
                "Seletor", "Título", "Gênero", "Ano", "Tipo", "Pontuação");

        // Linha separadora
        printLinha(colSeletor, colTitulo, colGenero, colAno, colTipo, colPontuacao);

        // Dados das mídias
        for (int i = 0; i < medias.size(); i++) {
            Media media = medias.get(i);
            String titulo = media.getTitulo();
            String genero = media.getGeneros().stream().map(g -> g.getNome()).toList().toString();
            String ano = String.valueOf(media.getDataLancamento().getYear());
            String tipoMedia = media.getTipoMedia().getDescricao();
            String seletor = String.valueOf(i);
            String pontuacao = String.valueOf(media.getPontuacao());

            // Trunca os textos que ultrapassam o tamanho da coluna
            if (titulo.length() > colTitulo) {
                titulo = titulo.substring(0, colTitulo - 3) + "...";
            }

            if (genero.length() > colGenero) {
                genero = genero.substring(0, colGenero - 3) + "...";
            }

            if (tipoMedia.length() > colTipo) {
                tipoMedia = tipoMedia.substring(0, colTipo - 3) + "...";
            }

            // Imprime os dados formatados na tabela
            System.out.printf("| %-"+colSeletor+"s | %-"+colTitulo+"s | %-"+colGenero+"s | %-"+colAno+"s | %-"+colTipo+"s | %-"+colPontuacao+"s |%n",
                    seletor, titulo, genero, ano, tipoMedia, pontuacao);
        }

        // Linha inferior
        printLinha(colSeletor, colTitulo, colGenero, colAno, colTipo, colPontuacao);
    }

    /**
     * Imprime uma linha separadora no formato de tabela, com base nos tamanhos das colunas fornecidos.
     *
     * @param col1 Tamanho da primeira coluna.
     * @param col2 Tamanho da segunda coluna.
     * @param col3 Tamanho da terceira coluna.
     * @param col4 Tamanho da quarta coluna.
     * @param col5 Tamanho da quinta coluna.
     * @param col6 Tamanho da sexta coluna.
     */
    private static void printLinha(int col1, int col2, int col3, int col4, int col5, int col6) {
        System.out.print("+");
        printRepetido('-', col1 + 2);
        System.out.print("+");
        printRepetido('-', col2 + 2);
        System.out.print("+");
        printRepetido('-', col3 + 2);
        System.out.print("+");
        printRepetido('-', col4 + 2);
        System.out.print("+");
        printRepetido('-', col5 + 2);
        System.out.print("+");
        printRepetido('-', col6 + 2);
        System.out.println("+");
    }

    /**
     * Imprime um caractere repetido várias vezes.
     *
     * @param c O caractere a ser impresso.
     * @param vezes O número de vezes que o caractere será impresso.
     */
    private static void printRepetido(char c, int vezes) {
        for (int i = 0; i < vezes; i++) {
            System.out.print(c);
        }
    }
}

=========================

==========================
{src/view/ListMidia.java}
package view;

import controller.search.SearchResults;
import model.Media;
import view.commons.IScreen;
import view.commons.ViewCommons;

import java.util.List;
import java.util.Scanner;

/**
 * Classe abstrata que representa uma tela de listagem de mídias (como filmes, livros, etc.) no sistema.
 * A classe permite a visualização de uma lista de mídias e oferece opções de interação, como buscar mídias,
 * selecionar uma mídia ou voltar à tela anterior.
 */
public abstract class ListMidia implements IScreen {
    protected List<Media> medias; // Lista de mídias a ser exibida
    private boolean reset = true;  // Flag para resetar a tela
    private String message;        // Mensagem associada à busca

    /**
     * Construtor da classe. Inicializa a lista de mídias com base nos resultados da busca.
     *
     * @param searchResults Resultados da busca contendo a lista de mídias e mensagem.
     */
    public ListMidia(SearchResults searchResults) {
        medias = searchResults.getMediaList();
        message = searchResults.getMessage();
    }

    /**
     * Exibe a lista de mídias na tela com base nas opções disponíveis para o usuário.
     * Permite ao usuário buscar mídias, selecionar uma mídia ou voltar.
     *
     * @param terminal Scanner usado para capturar entradas do usuário.
     */
    @Override
    public void draw(Scanner terminal) {
        if (medias == null) {
            System.out.println("Error: List of Medias was not set");
            return;
        }
        String input;
        do {
            // Exibe a lista de mídias ou uma mensagem se a lista estiver vazia
            if (reset) {
                if (medias.isEmpty()) {
                    System.out.println("\n=== Lista de "+ getNomeMidia() + " ===");
                    System.out.println("Nenhuma mídia encontrada.");
                    reset = false;
                } else {
                    System.out.println("\n=== Lista de "+ getNomeMidia() + " ===");
                    new ListGridMedia().draw(medias);
                    reset = false;
                }
            }
            // Exibe as opções de interação
            System.out.println("\n========= Opções ========");
            System.out.println(" 1 - Buscar " + getNomeMidia());
            System.out.println(" 2 - Selecionar " + getNomeMidia());
            System.out.println(" 3 - Voltar");
            System.out.print("Escolha uma opção: ");
            input = terminal.nextLine();
            switch (input) {
                case "1":
                    goToSearch(terminal); // Chama o método para buscar mídias
                    return;
                case "2":
                    // Permite selecionar uma mídia da lista
                    if (medias.isEmpty()) {
                        break;
                    }
                    int mediaId = ViewCommons.inputIntWRange(terminal, "\nÍndice do(a) " + getNomeMidia() +" selecionado(a): ", 0, medias.size() - 1);
                    goToDisplay(terminal, mediaId); // Chama o método para exibir a mídia selecionada
                    reset = true;
                    break;
                case "3":
                    return; // Volta à tela anterior
                default:
                    System.out.println("Opção inválida. Tente novamente.");
            }
        } while (!input.equals("4"));
    }

    /**
     * Atualiza a lista de mídias com os resultados de busca fornecidos.
     *
     * @param medias Resultados da busca contendo a lista de mídias e mensagem.
     */
    public void setMedias(SearchResults medias) {
        this.medias = medias.getMediaList();
        this.message = medias.getMessage();
    }

    /**
     * Método abstrato que define a busca de mídias.
     *
     * @param terminal Scanner usado para capturar entradas do usuário.
     */
    public abstract void goToSearch(Scanner terminal);

    /**
     * Método abstrato que define a exibição de uma mídia selecionada.
     *
     * @param terminal Scanner usado para capturar entradas do usuário.
     * @param id O índice da mídia selecionada na lista.
     */
    public abstract void goToDisplay(Scanner terminal, int id);

    /**
     * Método abstrato que retorna o nome da mídia (como "Filme", "Livro", etc.).
     *
     * @return O nome da mídia.
     */
    public abstract String getNomeMidia();
}

=========================

==========================
{src/view/Menu.java}
package view;

import view.commons.Screen;
import view.genero.GeneroMenu;

import java.util.Scanner;

/**
 * Classe que representa o menu principal do sistema "Diário Cultural".
 * O menu oferece opções para criar, listar mídias, acessar o menu de gêneros, ou sair do sistema.
 */
public class Menu extends Screen {

    /**
     * Método responsável por desenhar e exibir o menu principal do sistema.
     * O menu permite ao usuário escolher entre criar mídia, listar mídias,
     * acessar os gêneros ou sair do sistema.
     *
     * @param terminal Scanner usado para capturar entradas do usuário.
     */
    @Override
    public void draw(Scanner terminal) {
        String opcao;

        do {
            // Exibe o menu com as opções
            System.out.println("\n=== Bem-Vindo ao Diario Cultural ===");
            System.out.println("1 - Criar Midia");
            System.out.println("2 - Listar Midia");
            System.out.println("3 - Generos");
            System.out.println("4 - Sair");
            System.out.print("Escolha uma opção: ");

            opcao = terminal.nextLine();

            // Processa a opção escolhida pelo usuário
            switch (opcao) {
                case "1":
                    // Chama o menu para criar uma nova mídia
                    new MenuCreateMedia().draw(terminal);
                    break;
                case "2":
                    // Chama o menu para listar as mídias existentes
                    new MenuListMedia().draw(terminal);
                    break;
                case "3":
                    // Chama o menu de gêneros
                    new GeneroMenu().draw(terminal);
                    break;
                case "4":
                    // Exibe mensagem de saída e encerra o loop
                    System.out.println("Saindo do sistema...");
                    break;
                default:
                    // Caso o usuário digite uma opção inválida
                    System.out.println("Opção inválida! Tente novamente.");
            }
        } while (!opcao.equals("4")); // O loop continua até que o usuário escolha sair
    }
}

=========================

==========================
{src/view/MenuCreateMedia.java}
package view;

import view.commons.Screen;
import view.filme.CreateFilmeForm;
import view.livro.CreateLivroForm;
import view.serie.CreateSerieForm;

import java.util.Scanner;

/**
 * Classe que representa o menu para criação de novas mídias.
 * O menu oferece opções para criar um filme, uma série ou um livro.
 */
public class MenuCreateMedia extends Screen {

    /**
     * Método responsável por desenhar e exibir o menu de criação de mídia.
     * O menu permite ao usuário escolher entre criar um filme, uma série ou um livro,
     * ou voltar para o menu anterior.
     *
     * @param terminal Scanner usado para capturar entradas do usuário.
     */
    @Override
    public void draw(Scanner terminal) {
        String opcao;

        do {
            // Exibe o menu de criação de mídia com as opções disponíveis
            System.out.println("\n=== Criar Media ===");
            System.out.println("1 - Criar Filme");
            System.out.println("2 - Criar Serie");
            System.out.println("3 - Criar Livro");
            System.out.println("4 - Voltar");
            System.out.print("Escolha uma opção: ");

            opcao = terminal.nextLine();

            // Processa a opção escolhida pelo usuário
            switch (opcao) {
                case "1":
                    // Chama o formulário para criar um filme
                    new CreateFilmeForm().draw(terminal);
                    break;
                case "2":
                    // Chama o formulário para criar uma série
                    new CreateSerieForm().draw(terminal);
                    break;
                case "3":
                    // Chama o formulário para criar um livro
                    new CreateLivroForm().draw(terminal);
                    break;
                case "4":
                    // Volta ao menu anterior
                    return;
                default:
                    // Caso o usuário digite uma opção inválida
                    System.out.println("Opção inválida! Tente novamente.");
            }
        } while (!opcao.equals("4")); // O loop continua até que o usuário escolha voltar
    }
}

=========================

==========================
{src/view/MenuListMedia.java}
package view;

import controller.search.SearchFields;
import controller.search.filme.SearchFilmeController;
import controller.search.livro.SearchLivroController;
import controller.search.serie.SearchSerieController;
import view.commons.Screen;
import view.filme.FilmeListMidia;
import view.livro.LivroListMidia;
import view.serie.SerieListMidia;

import java.util.Scanner;

/**
 * Classe que representa o menu para listar mídias.
 * O menu oferece opções para listar filmes, séries ou livros.
 */
public class MenuListMedia extends Screen {

    /**
     * Método responsável por desenhar e exibir o menu de listagem de mídias.
     * O menu permite ao usuário escolher entre listar filmes, séries ou livros,
     * ou voltar para o menu anterior.
     *
     * @param terminal Scanner usado para capturar entradas do usuário.
     */
    @Override
    public void draw(Scanner terminal) {
        String opcao;

        do {
            // Exibe o menu de listagem de mídias com as opções disponíveis
            System.out.println("\n=== Listar Media ===");
            System.out.println("1 - Listar Filme");
            System.out.println("2 - Listar Serie");
            System.out.println("3 - Listar Livro");
            System.out.println("4 - Voltar");
            System.out.print("Escolha uma opção: ");

            opcao = terminal.nextLine();

            // Processa a opção escolhida pelo usuário
            switch (opcao) {
                case "1":
                    // Executa a busca e exibe a lista de filmes
                    SearchFilmeController searchController = new SearchFilmeController(null, SearchFields.TUDO);
                    searchController.execute();
                    new FilmeListMidia(searchController.getSearchResults()).draw(terminal);
                    break;
                case "2":
                    // Executa a busca e exibe a lista de séries
                    SearchSerieController searchSerieController = new SearchSerieController(null, SearchFields.TUDO);
                    searchSerieController.execute();
                    new SerieListMidia(searchSerieController.getSearchResults()).draw(terminal);
                    break;
                case "3":
                    // Executa a busca e exibe a lista de livros
                    SearchLivroController searchLivroController = new SearchLivroController(null, SearchFields.TUDO);
                    searchLivroController.execute();
                    new LivroListMidia(searchLivroController.getSearchResults()).draw(terminal);
                    break;
                case "4":
                    // Volta ao menu anterior
                    return;
                default:
                    // Caso o usuário digite uma opção inválida
                    System.out.println("Opção inválida! Tente novamente.");
            }
        } while (!opcao.equals("4")); // O loop continua até que o usuário escolha voltar
    }
}

=========================

==========================
{src/view/SearchView.java}
package view;

import controller.filter.*;
import controller.search.SearchFields;
import controller.search.SearchResults;
import model.Genero;
import view.commons.ViewCommons;

import java.util.AbstractMap.SimpleEntry;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

/**
 * Classe abstrata que representa a visualização de busca de mídias.
 * Permite ao usuário realizar buscas com filtros e opções de ordenação,
 * como gênero e ano, e exibe os resultados conforme os parâmetros fornecidos.
 */
public abstract class SearchView {

    /**
     * Método responsável por desenhar e exibir a tela de busca de mídias.
     * O usuário pode selecionar o campo de busca (por exemplo, por título, autor, etc.),
     * aplicar filtros adicionais por gênero e ano, e escolher a ordem de exibição dos resultados.
     *
     * @param terminal Scanner utilizado para capturar entradas do usuário.
     * @return Resultados da busca com os filtros e parâmetros definidos.
     */
    public SearchResults draw(Scanner terminal) {
        String valor = null;
        int opcao;
        List<SimpleEntry<String, SearchFields>> filterFields = getFields();
        FilterChain filterChain = new FilterChain();

        System.out.println("\n=== Busca de Mídia");

        // Exibe os campos de busca disponíveis para o usuário
        for (int i = 0; i < filterFields.size(); i++) {
            System.out.println((i + 1) + " - " + filterFields.get(i).getKey());
        }

        // Solicita ao usuário a escolha do campo para a busca
        opcao = ViewCommons.inputIntWRange(terminal, "selecione o campo para busca (caso selecione 'tudo' será feita uma busca geral): ", 1, filterFields.size() + 1);

        // Se a opção não for a busca geral, solicita o valor para o filtro
        if (opcao != 1) {
            System.out.print("Digite o valor para busca: ");
            valor = terminal.nextLine();
        }

        // Verifica se o usuário deseja filtrar por gênero
        boolean filterGenre = ViewCommons.inputBoolean(terminal, "\nDeseja filtrar por Genero?");
        if (filterGenre) {
            filterChain.addFilter(filterGenreView(terminal));
        }

        // Verifica se o usuário deseja filtrar por ano
        boolean FilterAno = ViewCommons.inputBoolean(terminal, "\nDeseja filtrar por Ano?");
        if (FilterAno) {
            filterChain.addFilter(filterYearView(terminal));
        }

        // Obtém o campo de busca selecionado pelo usuário
        SearchFields field = (filterFields.get(opcao - 1).getValue());

        // Solicita ao usuário a opção de ordenação dos resultados
        System.out.println("\nVocê deseja ordenar o resultado por: \n(S) Melhor avaliado.\n(N) Pior avaliado.\n");
        boolean ordenacao = ViewCommons.inputBoolean(terminal, "Selecione a opção de ordenação");

        // Executa a busca com os parâmetros definidos
        return execute(field, filterChain, valor, ordenacao);
    }

    /**
     * Método abstrato que deve ser implementado para fornecer os campos de busca disponíveis.
     *
     * @return Lista de campos de busca e suas representações do tipo {@link SearchFields}.
     */
    public abstract List<SimpleEntry<String, SearchFields>> getFields();

    /**
     * Método abstrato que executa a busca utilizando os filtros e parâmetros fornecidos.
     *
     * @param field       Campo de busca selecionado.
     * @param filterChain Filtros aplicados na busca.
     * @param value       Valor para busca (caso o campo não seja "tudo").
     * @param ordenacao   Define se a busca será ordenada por melhor ou pior avaliação.
     * @return Resultados da busca de mídia.
     */
    public abstract SearchResults execute(SearchFields field, FilterChain filterChain, String value, boolean ordenacao);

    /**
     * Método que exibe a tela para filtrar por gênero e retorna o filtro selecionado.
     *
     * @param terminal Scanner utilizado para capturar entradas do usuário.
     * @return O filtro de gênero selecionado.
     */
    public Filter filterGenreView(Scanner terminal) {

        List<SimpleEntry<String, GenreFilterType>> tiposGenero =
                Arrays.stream(GenreFilterType.values())
                        .map(field -> new SimpleEntry<>(field.getDescricao(), field))
                        .collect(Collectors.toList());

        System.out.println("\n=== Tipos de filtro de genero");

        // Exibe as opções de filtro por gênero
        for (int i = 0; i < tiposGenero.size(); i++) {
            System.out.println((i + 1) + " - " + tiposGenero.get(i).getKey());
        }

        // Solicita ao usuário a escolha do tipo de filtro de gênero
        int genreTypeFilter = ViewCommons.inputIntWRange(terminal, "Selecione o tipo de filtro: ", 1, 4);
        GenreFilterType genreFilterType = tiposGenero.get(genreTypeFilter - 1).getValue();

        // Solicita o valor para o filtro de gênero
        System.out.println("\nDigite o valor para filtro: ");
        List<Genero> GenreValue = ViewCommons.inputGenero(terminal);
        GenreFilter genreFilter = new GenreFilter(genreFilterType, GenreValue);
        return genreFilter;
    }

    /**
     * Método que exibe a tela para filtrar por ano e retorna o filtro de ano selecionado.
     *
     * @param terminal Scanner utilizado para capturar entradas do usuário.
     * @return O filtro de ano selecionado.
     */
    public Filter filterYearView(Scanner terminal) {
        List<SimpleEntry<String, YearFilterType>> tiposAno =
                Arrays.stream(YearFilterType.values())
                        .map(field -> new SimpleEntry<>(field.getDescricao(), field))
                        .collect(Collectors.toList());

        System.out.println("=== Tipos de filtro de ano");

        // Exibe as opções de filtro por ano
        for (int i = 0; i < tiposAno.size(); i++) {
            System.out.println((i + 1) + " - " + tiposAno.get(i).getKey());
        }

        // Solicita ao usuário a escolha do tipo de filtro de ano
        int yearTypeFilter = ViewCommons.inputIntWRange(terminal, "Selecione o tipo de filtro: ", 1, 4);
        YearFilterType yearFilterType = tiposAno.get(yearTypeFilter - 1).getValue();

        // Solicita o valor para o filtro de ano
        System.out.println("Digite o valor para filtro de ano: ");
        int anoValue = ViewCommons.inputInt(terminal, "Ano: ");
        YearFilter yearFilter = new YearFilter(yearFilterType, anoValue);
        return yearFilter;
    }
}

=========================

==========================
{src/view/avaliacao/AvaliacaoDisplay.java}
package view.avaliacao;

import controller.util.DateFormater;
import model.Avaliacao;

/**
 * A classe {@code AvaliacaoDisplay} é responsável por exibir no console os detalhes de uma avaliação de forma formatada.
 * Ela usa a classe {@link DateFormater} para formatar as datas da avaliação e de consumo.
 *
 * A principal função desta classe é fornecer uma maneira de mostrar informações sobre uma avaliação,
 * como a data da avaliação, a data em que a mídia foi consumida, a pontuação dada na avaliação, e o comentário.
 *
 * <p>Exemplo de uso:</p>
 * <pre>
 * Avaliacao avaliacao = new Avaliacao(...);
 * AvaliacaoDisplay display = new AvaliacaoDisplay(avaliacao);
 * display.draw();
 * </pre>
 *
 * @author
 */
public class AvaliacaoDisplay {

    /** A avaliação que será exibida. */
    private Avaliacao avaliacao;

    /**
     * Construtor da classe, recebe uma avaliação e prepara para exibi-la.
     *
     * @param avaliacao A avaliação a ser exibida.
     */
    public AvaliacaoDisplay(Avaliacao avaliacao) {
        this.avaliacao = avaliacao;
    }

    /**
     * Exibe no console as informações detalhadas da avaliação.
     * A exibição inclui a data da avaliação formatada, a data em que a mídia foi consumida,
     * a pontuação atribuída na avaliação, e o comentário associado.
     */
    public void draw(){
        System.out.println("Data da Avaliação: " + DateFormater.DataHora(avaliacao.getDataAvaliacao()));
        System.out.println("--------------------");
        System.out.println("Dia que assistiu/leu: " + avaliacao.getDataConsumo());
        System.out.println("Avaliação: " + avaliacao.getPontuacao());
        System.out.println("Comentário: " + avaliacao.getReview());
    }
}

=========================

==========================
{src/view/avaliacao/CreateAvaliacaoForm.java}
package view.avaliacao;

import controller.action.ActionResult;
import controller.action.avaliacao.CreateAvaliacaoAction;
import controller.action.avaliacao.CreateAvaliacaoValidation;
import model.Avaliacao;
import model.commons.IAvaliavel;
import view.commons.Screen;
import view.commons.ViewCommons;

import java.time.LocalDate;
import java.util.Scanner;

/**
 * A classe {@code CreateAvaliacaoForm} é responsável por exibir um formulário de criação de avaliação para o usuário.
 * Ela coleta as informações necessárias para criar uma avaliação de uma mídia, incluindo o comentário, a pontuação e a data de consumo.
 *
 * Esta classe interage com a lógica de negócios para validar e salvar a avaliação por meio da ação {@link CreateAvaliacaoAction}.
 * O formulário repete o processo até que uma avaliação válida seja fornecida.
 *
 * <p>Exemplo de uso:</p>
 * <pre>
 * CreateAvaliacaoForm form = new CreateAvaliacaoForm();
 * form.setObjAvaliavel(someAvaliavelObject);
 * form.draw(new Scanner(System.in));
 * </pre>
 *
 * @author
 */
public class CreateAvaliacaoForm extends Screen {

    /** O objeto que pode ser avaliado. */
    private IAvaliavel objAvaliavel;

    /**
     * Exibe o formulário de criação de avaliação e coleta as entradas do usuário.
     * O formulário solicita um comentário, uma pontuação (entre 1 e 5), e a data de consumo da mídia.
     * O processo continua até que a avaliação seja validada com sucesso.
     *
     * @param terminal O scanner usado para ler as entradas do usuário.
     */
    @Override
    public void draw(Scanner terminal) {
        ActionResult result;
        Avaliacao avaliacao;

        do {
            System.out.println("\n=== Avaliar Mídia ===\n");
            System.out.print("Comentário: ");
            String review = terminal.nextLine();

            int pontuacao = ViewCommons.inputIntWRange(terminal, "Pontuação (1-5): ", 1, 5);
            LocalDate data_consumo = ViewCommons.inputData(terminal, "Data que assistiu/leu");

            avaliacao = new Avaliacao(null, pontuacao, review, data_consumo);

            CreateAvaliacaoAction createAvaliacao = new CreateAvaliacaoAction(new CreateAvaliacaoValidation());

            createAvaliacao.setSuperModel(objAvaliavel);
            result = createAvaliacao.execute(avaliacao);
            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess());
    }

    /**
     * Define o objeto avaliável, ou seja, o objeto ao qual a avaliação será associada.
     *
     * @param objAvaliavel O objeto que pode ser avaliado.
     */
    public void setObjAvaliavel(IAvaliavel objAvaliavel) {
        this.objAvaliavel = objAvaliavel;
    }

    /**
     * Retorna o objeto avaliável.
     *
     * @return O objeto que pode ser avaliado.
     */
    public IAvaliavel getObjAvaliavel() {
        return objAvaliavel;
    }
}

=========================

==========================
{src/view/commons/IScreen.java}
package view.commons;

import java.util.Scanner;

/**
 * A interface {@code IScreen} define a estrutura para telas interativas que desenham (ou exibem) conteúdo no terminal.
 *
 * Qualquer classe que implemente esta interface deve fornecer uma implementação do método {@link #draw(Scanner)} para desenhar a tela.
 * O método {@code draw} é responsável por exibir informações e coletar entradas do usuário através de um {@link Scanner}.
 *
 * <p>Exemplo de implementação:</p>
 * <pre>
 * public class ExemploTela implements IScreen {
 *     @Override
 *     public void draw(Scanner terminal) {
 *         System.out.println("Exibindo conteúdo na tela.");
 *         // Lógica para coletar e processar a entrada do usuário.
 *     }
 * }
 * </pre>
 *
 * @author
 */
public interface IScreen {

    /**
     * Método responsável por desenhar (exibir) o conteúdo da tela e coletar entradas do usuário.
     *
     * @param terminal O scanner usado para ler as entradas do usuário.
     */
    void draw(Scanner terminal);
}

=========================

==========================
{src/view/commons/Screen.java}
package view.commons;

/**
 * A classe abstrata {@code Screen} implementa a interface {@link IScreen} e fornece métodos auxiliares para telas interativas.
 *
 * <p>Ela contém métodos para limpar a tela do terminal e para aguardar um tempo especificado.</p>
 *
 * <p>As classes que extendem {@code Screen} podem aproveitar esses métodos e devem fornecer a implementação para o método,
 * que é responsável por desenhar o conteúdo da tela e coletar entradas do usuário.</p>
 *
 * <p>Exemplo de uso:</p>
 * <pre>
 * public class ExemploTela extends Screen {
 *     @Override
 *     public void draw(Scanner terminal) {
 *         clear();  // Limpa a tela
 *         System.out.println("Exibindo conteúdo na tela.");
 *         await();  // Aguardar 2 segundos
 *     }
 * }
 * </pre>
 *
 * @author
 */
public abstract class Screen implements IScreen {

    /**
     * Limpa a tela do terminal. Dependendo do sistema operacional, utiliza o comando apropriado.
     * No Windows, o comando {@code cls} é utilizado, enquanto no Linux/Mac é utilizado o comando {@code clear}.
     *
     * Se ocorrer algum erro ao limpar a tela, uma mensagem de erro será exibida no terminal.
     */
    public void clear() {
        try {
            if (System.getProperty("os.name").contains("Windows")) {
                new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();
            } else {
                new ProcessBuilder("clear").inheritIO().start().waitFor();
            }
        } catch (Exception e) {
            System.out.println("Erro ao limpar a tela: " + e.getMessage());
        }
    }

    /**
     * Aguarda por 2 segundos (2000 milissegundos). Este método pode ser usado para criar pausas entre exibições de telas.
     */
    public void await() {
        try {
            Thread.sleep(2000); // Pausa por 2 segundos (2000 milissegundos)
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

=========================

==========================
{src/view/commons/ViewCommons.java}
package view.commons;

import controller.dataBase.GeneroRepository;
import model.Genero;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * A classe {@code ViewCommons} contém métodos auxiliares para interação com o terminal,
 * fornecendo funcionalidades como entrada de dados para gêneros, elenco, anos, entre outros.
 *
 * <p>Essa classe facilita a coleta de entradas de usuários em telas interativas, validando as entradas
 * e oferecendo uma interface para coleta de dados comuns, como listas, inteiros, booleans e datas.</p>
 *
 * <p>Exemplo de uso:</p>
 * <pre>
 * Scanner scanner = new Scanner(System.in);
 * int ano = ViewCommons.inputAno(scanner, "Digite o ano de lançamento");
 * </pre>
 *
 */
public class ViewCommons {

    /**
     * Solicita ao usuário a seleção de gêneros e retorna uma lista de objetos {@link Genero} selecionados.
     * O usuário pode continuar selecionando gêneros até decidir parar, digitando '-1'.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @return Uma lista de objetos {@link Genero} selecionados pelo usuário.
     */
    public static List<Genero> inputGenero(Scanner terminal) {
        List<Genero> generos = new ArrayList<>();
        GeneroRepository generoRepository = GeneroRepository.getInstance();
        int generoId;

        System.out.println("=== Gêneros disponíveis ");
        for (Genero g : generoRepository.getItems()) {
            System.out.println(g.getId() + " - " + g.getNome());
        }

        do {
            System.out.println("Lista atual: " + generos);
            generoId = inputIntOrExit(terminal, "Selecione o genero(ou '-1' para finalizar): ");

            if (generoId == -1) {
                break;
            }

            Genero generoSelecionado = generoRepository.getItemById(generoId);

            if (generoSelecionado != null) {
                if (generos.contains(generoSelecionado)) {
                    System.out.println("Gênero já adicionado. Tente novamente.");
                } else {
                    generos.add(generoSelecionado);
                }

            } else {
                System.out.println("Gênero inválido. Tente novamente.");
            }
        } while (true);
        return generos;
    }

    /**
     * Solicita ao usuário a entrada do elenco (atores/atrizes) e retorna uma lista com os nomes dos integrantes.
     * O usuário pode adicionar múltiplos atores até digitar 'sair' para finalizar.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @return Uma lista de strings representando os nomes dos atores/atrizes.
     */
    public static List<String> inputElenco(Scanner terminal) {
        List<String> elenco = new ArrayList<>();
        String ator;
        System.out.println("=== Elenco ");
        do {
            System.out.println("Lista atual: " + elenco);
            System.out.print("Ator/atriz (ou 'sair' para finalizar): ");
            ator = terminal.nextLine();
            if (ator.equalsIgnoreCase("sair")) {
                break;
            }
            String finalAtor = ator;
            if (elenco.stream().anyMatch(a -> a.equalsIgnoreCase(finalAtor))) {
                System.out.println("Ator/atriz já adicionado. Tente novamente.");
                continue;
            }
            if (ator.isEmpty()) {
                System.out.println("Nome inválido. Tente novamente.");
                continue;
            }
            elenco.add(ator);
            System.out.println("Ator/atriz adicionado: " + ator);
        } while (!ator.equalsIgnoreCase("sair"));
        return elenco;
    }

    /**
     * Solicita ao usuário o ano de lançamento e retorna um valor inteiro validado.
     * O ano deve ser informado no formato de 4 dígitos (YYYY).
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @param message A mensagem a ser exibida ao usuário para solicitar a entrada.
     * @return O ano de lançamento como um valor inteiro.
     */
    public static int inputAno(Scanner terminal, String message) {
        String anoLancamento;
        int ano;
        do {
            System.out.print(message + " (YYYY): ");
            anoLancamento = terminal.nextLine();
            if (anoLancamento.length() != 4 || !anoLancamento.matches("[0-9]+")) {
                System.out.println("Ano inválido. Tente novamente.");
            }
        } while (anoLancamento.length() != 4 || !anoLancamento.matches("[0-9]+"));
        ano = Integer.parseInt(anoLancamento);
        return ano;
    }

    /**
     * Solicita ao usuário um valor inteiro e retorna esse valor após validá-lo.
     * O valor deve ser um número inteiro positivo.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @param message A mensagem a ser exibida ao usuário para solicitar a entrada.
     * @return O valor inteiro fornecido pelo usuário.
     */
    public static int inputInt(Scanner terminal, String message) {
        String input;
        int value;
        do {
            System.out.print(message);
            input = terminal.nextLine();
            if (!input.matches("[0-9]+")) {
                System.out.println("Valor inválido. Tente novamente.");
            }
        } while (!input.matches("[0-9]+"));
        value = Integer.parseInt(input);
        return value;
    }

    /**
     * Solicita ao usuário um valor inteiro ou a opção de sair (valor -1).
     * O valor deve ser um número inteiro ou '-1' para finalizar a seleção.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @param message A mensagem a ser exibida ao usuário para solicitar a entrada.
     * @return O valor inteiro fornecido pelo usuário, ou '-1' para sair.
     */
    public static int inputIntOrExit(Scanner terminal, String message) {
        String input;
        int value;
        do {
            System.out.print(message);
            input = terminal.nextLine();
            if (!input.matches("^(-1|\\d+)$")) {
                System.out.println("Valor inválido. Tente novamente.");
            }
        } while (!input.matches("^(-1|\\d+)$"));
        value = Integer.parseInt(input);
        return value;
    }

    /**
     * Solicita ao usuário uma entrada booleana (Sim/Não) e retorna o valor correspondente.
     * O valor deve ser 's' ou 'n', representando Sim e Não, respectivamente.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @param message A mensagem a ser exibida ao usuário para solicitar a entrada.
     * @return O valor booleano correspondente à entrada do usuário.
     */
    public static boolean inputBoolean(Scanner terminal, String message) {
        String input;
        boolean value;
        do {
            System.out.print(message + ("(S/N): "));
            input = terminal.nextLine();
            if (!input.equalsIgnoreCase("s") && !input.equalsIgnoreCase("n")) {
                System.out.println("Valor inválido. Tente novamente.");
            }
        } while (!input.equalsIgnoreCase("s") && !input.equalsIgnoreCase("n"));

        if (input.equalsIgnoreCase("s"))
            value = true;
        else
            value = false;

        System.out.println("Valor selecionado: " + (value ? "Sim" : "Não"));
        return value;
    }

    /**
     * Solicita ao usuário um valor inteiro dentro de um intervalo específico e retorna o valor.
     * O valor deve estar dentro do intervalo definido entre {@code min} e {@code max}.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @param message A mensagem a ser exibida ao usuário para solicitar a entrada.
     * @param min O valor mínimo permitido.
     * @param max O valor máximo permitido.
     * @return O valor inteiro fornecido pelo usuário dentro do intervalo.
     */
    public static int inputIntWRange(Scanner terminal, String message, int min, int max) {
        int input;
        do {
            input = inputInt(terminal, message);

            if(input == -1){
                break;
            }
            if (input < min || input > max) {
                System.out.println("Valor fora do intervalo. Tente novamente.");
            }

        } while (input < min || input > max );
        return input;
    }

    /**
     * Solicita ao usuário um valor inteiro negativo e retorna esse valor após validá-lo.
     * O valor deve ser um número inteiro, incluindo números negativos.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @param message A mensagem a ser exibida ao usuário para solicitar a entrada.
     * @return O valor inteiro negativo fornecido pelo usuário.
     */
    public static int inputNegativeInt(Scanner terminal, String message) {
        String input;
        int value;
        do {
            System.out.print(message);
            input = terminal.nextLine();
            if (!input.matches("-?[0-9]+")) {
                System.out.println("Valor inválido. Tente novamente.");
            }
        } while (!input.matches("-?[0-9]+"));
        value = Integer.parseInt(input);
        return value;
    }

    /**
     * Solicita ao usuário uma data no formato "dd/MM/yyyy" e retorna o valor de data validado.
     *
     * @param terminal O scanner usado para capturar entradas do terminal.
     * @param message A mensagem a ser exibida ao usuário para solicitar a entrada.
     * @return O valor da data fornecida pelo usuário.
     */
    public static LocalDate inputData(Scanner terminal, String message) {
        LocalDate data = null;
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");

        while (true) {
            System.out.print(message + " (formato: dd/MM/yyyy): ");
            String input = terminal.nextLine();

            try {
                data = LocalDate.parse(input, formatter);
                break;
            } catch (DateTimeParseException e) {
                System.out.println("Data inválida. Tente novamente.");
            }
        }

        return data;
    }

}





=========================

==========================
{src/view/filme/CreateFilmeForm.java}
package view.filme;

import controller.dataBase.GeneroRepository;
import controller.action.filme.CreateFilmeAction;
import controller.action.filme.CreateFilmeValidation;
import controller.action.ActionResult;
import model.Filme;
import model.Genero;
import view.commons.Screen;
import view.commons.ViewCommons;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Scanner;

/**
 * Tela responsável por permitir ao usuário criar um novo filme, fornecendo detalhes como título, diretor, gêneros,
 * entre outros. Esta classe gerencia o processo de coleta das informações do filme, validação da entrada e criação
 * do objeto de filme.
 * <p>
 * A classe estende {@link view.commons.Screen} e implementa o processo de criação do filme de forma interativa
 * através do console. Ela garante que um filme só possa ser criado caso existam gêneros disponíveis no sistema.
 * </p>
 */
public class CreateFilmeForm extends Screen {

    /**
     * Solicita ao usuário que insira todos os detalhes necessários para criar um novo filme. Isso inclui:
     * <ul>
     *     <li>Título do filme</li>
     *     <li>Título original do filme</li>
     *     <li>Ano de lançamento</li>
     *     <li>Duração do filme em minutos</li>
     *     <li>Diretor</li>
     *     <li>Roteirista</li>
     *     <li>Local onde o filme está disponível</li>
     *     <li>Gêneros associados ao filme</li>
     *     <li>Elenco (atores/atrizes)</li>
     *     <li>Se o filme foi assistido ou não</li>
     * </ul>
     * <p>
     * O método valida as entradas, garantindo que todos os campos obrigatórios sejam fornecidos e formatados
     * corretamente. Se algum dado necessário estiver ausente ou inválido, o usuário será solicitado a corrigir a
     * informação.
     * </p>
     * Após coletar todos os dados, o método tenta criar um novo objeto {@link model.Filme} e processá-lo usando a
     * classe {@link controller.action.filme.CreateFilmeAction}.
     * <p>
     * Caso a criação do filme seja bem-sucedida, uma mensagem de sucesso será exibida. Caso contrário, o usuário
     * será solicitado a corrigir qualquer problema com os dados fornecidos.
     * </p>
     *
     * @param terminal o objeto scanner usado para ler a entrada do console
     */
    @Override
    public void draw(Scanner terminal) {
        if (GeneroRepository.getInstance().getItems().isEmpty()) {
            System.out.println("Nenhum genero cadastrado. Cadastre um genero antes de criar um filme.");
            return;
        }

        ActionResult result;
        Filme filme;

        do {
            System.out.println("\n=== Criar Filme ===\n");
            System.out.print("Titulo do filme: ");
            String nome = terminal.nextLine();
            System.out.print("Titulo Original: ");
            String nomeOriginal = terminal.nextLine();

            int AnoLancamento = ViewCommons.inputAno(terminal, "Ano de Lançamento");
            int duracao = ViewCommons.inputInt(terminal, "Duração (em minutos): ");

            System.out.print("Diretor: ");
            String diretor = terminal.nextLine();
            System.out.print("Roteiro: ");
            String roteiro = terminal.nextLine();
            System.out.print("Local disponível: ");
            String localDisponivel = terminal.nextLine();

            List<Genero> generosFilme = ViewCommons.inputGenero(terminal);
            List<String> elenco = ViewCommons.inputElenco(terminal);

            boolean consumido = ViewCommons.inputBoolean(terminal, "Já Assisti? ");

            filme = new Filme(nome, LocalDateTime.of(AnoLancamento, 1, 1, 0, 0),
                    consumido, generosFilme, nomeOriginal, localDisponivel,
                    elenco, diretor, duracao, roteiro);

            CreateFilmeAction createFilme = new CreateFilmeAction(new CreateFilmeValidation());
            result = createFilme.execute(filme);

            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess());

        new FilmeDisplay(filme).draw(terminal);
    }
}

=========================

==========================
{src/view/filme/FilmeDisplay.java}
package view.filme;

import controller.dataBase.FilmeRepository;
import model.Filme;
import view.avaliacao.AvaliacaoDisplay;
import view.avaliacao.CreateAvaliacaoForm;
import view.commons.Screen;

import java.util.Scanner;

/**
 * Tela que exibe os detalhes de um filme, incluindo seu título, ano de lançamento, gêneros, elenco e mais.
 * Também permite que o usuário execute ações relacionadas ao filme, como editar ou adicionar avaliações.
 * <p>
 * A classe estende {@link view.commons.Screen} e é responsável por apresentar uma visão completa de um filme,
 * incluindo uma lista de avaliações e a opção de classificar o filme ou editar suas informações. O usuário também
 * pode optar por voltar à tela anterior.
 * </p>
 */
public class FilmeDisplay extends Screen {
    private final Filme filme;

    /**
     * Constrói uma instância de {@link FilmeDisplay} com o objeto {@link Filme} fornecido.
     *
     * @param filme o filme a ser exibido
     */
    public FilmeDisplay(Filme filme) {
        this.filme = filme;
    }

    /**
     * Exibe os detalhes do filme, incluindo o título, título original, ano de lançamento, gêneros, diretor,
     * duração, elenco, local disponível, status de consumo e roteiro. Também exibe a lista de avaliações
     * (se houver) associadas ao filme.
     * <p>
     * Após mostrar os detalhes, o usuário tem as opções de:
     * <ul>
     *     <li>Editar os detalhes do filme</li>
     *     <li>Avaliar o filme (se assistido)</li>
     *     <li>Voltar para a tela anterior</li>
     * </ul>
     * O método solicita a entrada do usuário e responde de acordo com a opção escolhida.
     * Se o usuário escolher avaliar o filme, ele será direcionado para o {@link CreateAvaliacaoForm} para fornecer uma avaliação.
     * Se o usuário escolher editar o filme, ele será direcionado para o {@link UpdateFilmeForm}.
     * </p>
     *
     * @param terminal o objeto scanner usado para ler a entrada do console
     */
    @Override
    public void draw(Scanner terminal) {
        System.out.println("\n=== Detalhes do Filme ===");
        System.out.println("Título: " + filme.getTitulo());
        System.out.println("Título Original: " + filme.getTituloOriginal());
        System.out.println("Pontuação: " + filme.getPontuacao());
        System.out.println("Ano de Lançamento: " + filme.getDataLancamento().getYear());
        System.out.println("Gêneros: " + String.join(", ", filme.getGeneros().stream().map(g -> g.getNome()).toList()));
        System.out.println("Diretor: " + filme.getDirecao());
        System.out.println("Duração: " + filme.getDuracao() + " minutos");
        System.out.println("Elenco: " + String.join(", ", filme.getElenco()));
        System.out.println("Local Disponível: " + filme.getLocalDisponivel());
        System.out.println("Já assisti: " + (filme.isConsumido() ? "Sim" : "Não"));
        System.out.println("Roteiro: " + filme.getRoteiro());

        System.out.println("\n=== Avaliações ===");
        if (filme.getAvaliacoes().isEmpty()) {
            System.out.println("Nenhuma avaliação ainda.");
        } else {
            System.out.println("======================================");
            filme.getAvaliacoes().forEach(avaliacao -> {
                new AvaliacaoDisplay(avaliacao).draw();
                System.out.println("======================================");
            });
        }

        System.out.println("\n=== Ações ===");
        System.out.println("1. Editar");
        System.out.println("2. Avaliar");
        System.out.println("3. Voltar");

        String input;
        do {
            System.out.print("Escolha uma opção: ");
            input = terminal.nextLine();
            FilmeRepository filmeRepository = FilmeRepository.getInstance();

            switch (input) {
                case "1":
                    new UpdateFilmeForm(filme).draw(terminal);
                    new FilmeDisplay(FilmeRepository.getInstance().getItemById(filme.getId())).draw(terminal);
                    return;
                case "2":
                    // Avaliar filme
                    if (!filme.isConsumido()) {
                        System.out.println("Você precisa assistir o filme antes de avaliá-lo.");
                    } else {
                        CreateAvaliacaoForm createAvaliacaoForm = new CreateAvaliacaoForm();
                        createAvaliacaoForm.setObjAvaliavel(filme);
                        createAvaliacaoForm.draw(terminal);
                        Filme filmeAvaliado = filmeRepository.getItemById(filme.getId());
                        new FilmeDisplay(filmeAvaliado).draw(terminal);
                        return;
                    }
                case "3":
                    break;
                default:
                    System.out.println("Opção inválida.");
            }
        } while (!input.equals("3"));
    }
}

=========================

==========================
{src/view/filme/FilmeListMidia.java}
package view.filme;

import controller.search.SearchResults;
import model.Filme;
import view.ListMidia;
import view.SearchView;

import java.util.Scanner;

/**
 * Classe responsável por exibir uma lista de filmes e permitir que o usuário interaja com essa lista,
 * realizando pesquisas e visualizando detalhes de cada filme.
 * <p>
 * A classe estende {@link view.ListMidia} e fornece implementações específicas para filmes, permitindo que o
 * usuário busque filmes e veja os detalhes de um filme selecionado. Ela também é responsável por exibir a lista
 * de filmes com base nos resultados da pesquisa.
 * </p>
 */
public class FilmeListMidia  extends ListMidia {

    /**
     * Constrói uma instância de {@link FilmeListMidia} com os resultados de pesquisa fornecidos.
     *
     * @param searchResults os resultados da pesquisa de filmes
     */
    public FilmeListMidia(SearchResults searchResults) {
        super(searchResults);
    }

    /**
     * Redireciona o usuário para a tela de pesquisa de filmes.
     * Exibe a tela de pesquisa onde o usuário pode buscar por filmes.
     *
     * @param terminal o objeto scanner usado para ler a entrada do console
     */
    @Override
    public void goToSearch(Scanner terminal) {
        SearchView searchView = new SearchViewFilme();
        FilmeListMidia filmeListMidia =  new FilmeListMidia(searchView.draw(terminal));
        filmeListMidia.draw(terminal);
    }

    /**
     * Redireciona o usuário para a tela de exibição dos detalhes de um filme selecionado.
     *
     * @param terminal o objeto scanner usado para ler a entrada do console
     * @param id o identificador do filme selecionado
     */
    @Override
    public void goToDisplay(Scanner terminal, int id) {
        new FilmeDisplay((Filme) medias.get(id)).draw(terminal);
    }

    /**
     * Retorna o nome da mídia que está sendo exibida, que neste caso é "Filme".
     *
     * @return o nome da mídia
     */
    @Override
    public String getNomeMidia() {
        return "Filme";
    }
}

=========================

==========================
{src/view/filme/SearchViewFilme.java}
package view.filme;

import controller.filter.FilterChain;
import controller.search.SearchFields;
import controller.search.filme.SearchFilmeController;
import controller.search.SearchResults;
import view.SearchView;

import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.List;

/**
 * Classe responsável por exibir a tela de pesquisa específica para filmes, permitindo ao usuário realizar
 * buscas por filmes utilizando diferentes campos de pesquisa e filtros.
 * <p>
 * A classe herda de {@link view.SearchView} e fornece implementações específicas para filmes, incluindo os
 * campos de pesquisa disponíveis e a execução da busca. Ela utiliza a classe {@link SearchFilmeController}
 * para controlar a lógica de busca e retorna os resultados filtrados conforme os critérios fornecidos.
 * </p>
 */
public class SearchViewFilme extends SearchView {

    /**
     * Lista de campos de pesquisa disponíveis para o usuário ao buscar filmes.
     * Cada campo é representado por uma entrada simples contendo o nome do campo e a chave associada
     * da enumeração {@link SearchFields}.
     */
    List<SimpleEntry<String, SearchFields>> fields = new ArrayList<>();

    /**
     * Retorna a lista de campos disponíveis para pesquisa, cada um representando um critério que o usuário pode
     * selecionar para buscar filmes. Esses campos são definidos por meio da enumeração {@link SearchFields}.
     *
     * @return uma lista de entradas contendo o nome do campo e sua chave associada
     */
    @Override
    public List<SimpleEntry<String, SearchFields>> getFields() {
        fields.add(new SimpleEntry<>("Tudo", SearchFields.TUDO));
        fields.add(new SimpleEntry<>("Título", SearchFields.TITULO));
        fields.add(new SimpleEntry<>("Gênero", SearchFields.GENERO));
        fields.add(new SimpleEntry<>("Ano de Lançamento", SearchFields.ANO_LANCAMENTO));
        fields.add(new SimpleEntry<>("Diretor", SearchFields.DIRETOR));
        fields.add(new SimpleEntry<>("Duração", SearchFields.DURACAO));
        fields.add(new SimpleEntry<>("Elenco", SearchFields.ELENCO));
        fields.add(new SimpleEntry<>("Roteiro", SearchFields.ROTEIRO));

        return fields;
    }

    /**
     * Executa a busca de filmes de acordo com os parâmetros fornecidos. O método utiliza o controlador de busca
     * {@link SearchFilmeController} para processar a busca com base no valor e no campo de pesquisa selecionados,
     * aplicando também qualquer filtro e ordenação especificada.
     *
     * @param field o campo de pesquisa selecionado
     * @param filterChain a cadeia de filtros a ser aplicada na busca
     * @param value o valor de pesquisa fornecido pelo usuário
     * @param ordenacao um valor booleano que indica se a ordenação deve ser aplicada
     * @return os resultados da busca, encapsulados em um objeto {@link SearchResults}
     */
    @Override
    public SearchResults execute(SearchFields field, FilterChain filterChain, String value, boolean ordenacao) {
        SearchFilmeController searchFilmeController = new SearchFilmeController(value, field);
        searchFilmeController.setFilterChain(filterChain);
        searchFilmeController.setOrdenacao(ordenacao);
        searchFilmeController.execute();
        SearchResults searchResults = searchFilmeController.getSearchResults();
        return searchResults;
    }
}

=========================

==========================
{src/view/filme/UpdateFilmeForm.java}
package view.filme;

import controller.action.ActionResult;
import controller.action.filme.UpdateFilmeValidation;
import controller.action.filme.UpdateFilmeAction;
import model.Filme;
import view.commons.Screen;
import view.commons.ViewCommons;

import java.util.Scanner;

/**
 * Classe responsável por exibir o formulário de edição de um filme. Permite ao usuário alterar informações relacionadas
 * ao filme, como seu status de "já assistido".
 * <p>
 * A classe herda de {@link view.commons.Screen} e permite a modificação do estado do filme. A edição é feita por meio
 * de um formulário interativo que valida e aplica as mudanças no objeto filme. O processo de atualização é gerido
 * pela classe {@link controller.action.filme.UpdateFilmeAction}, que executa a lógica de validação e atualização.
 * </p>
 */
public class UpdateFilmeForm extends Screen {
    private Filme filme;

    /**
     * Construtor da classe {@link UpdateFilmeForm} que recebe o objeto {@link Filme} a ser editado.
     *
     * @param filme o filme a ser editado
     */
    public UpdateFilmeForm(Filme filme) {
        this.filme = filme;
    }

    /**
     * Exibe o formulário de edição para o filme. O usuário pode alterar o status de "já assistido" do filme.
     * O processo de validação e atualização é realizado por meio de {@link UpdateFilmeAction}.
     * <p>
     * O método garante que a atualização do filme só será realizada se a validação for bem-sucedida.
     * </p>
     *
     * @param terminal o objeto {@link Scanner} utilizado para ler as entradas do usuário
     */
    @Override
    public void draw(Scanner terminal) {
        ActionResult result;
        System.out.println("\n=== Editar Filme ===");
        do {
            // Solicita ao usuário se ele já assistiu o filme
            boolean consumido = ViewCommons.inputBoolean(terminal, "Já Assisti?");

            // Atualiza o status do filme com base na entrada do usuário
            filme.setConsumido(consumido);

            // Cria a ação de atualização do filme e executa
            UpdateFilmeAction updateFilme = new UpdateFilmeAction(new UpdateFilmeValidation());
            result = updateFilme.execute(filme);

            // Exibe o resultado da atualização
            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess());  // Continua tentando até a atualização ser bem-sucedida
    }
}

=========================

==========================
{src/view/genero/CreateGeneroForm.java}
package view.genero;

import controller.action.ActionResult;
import controller.action.genero.CreateGeneroAction;
import controller.action.genero.CreateGeneroValidation;
import model.Genero;
import view.commons.Screen;

import java.util.Scanner;

/**
 * Classe responsável por exibir o formulário de criação de um novo gênero. O usuário pode inserir o nome do
 * gênero e, se a validação for bem-sucedida, o gênero será criado no sistema.
 * <p>
 * A classe herda de {@link view.commons.Screen} e permite a criação de um gênero por meio de um formulário interativo.
 * A validação e a criação do gênero são realizadas pela classe {@link controller.action.genero.CreateGeneroAction}.
 * O processo continua até que um gênero seja criado com sucesso ou o usuário decida sair.
 * </p>
 */
public class CreateGeneroForm extends Screen {

    /**
     * Exibe o formulário para a criação de um gênero. O usuário pode inserir o nome do gênero ou digitar "sair" para
     * finalizar o processo. A validação do gênero é realizada por meio da classe {@link CreateGeneroAction}.
     *
     * @param terminal o objeto {@link Scanner} utilizado para ler as entradas do usuário
     */
    @Override
    public void draw(Scanner terminal) {
        ActionResult result;
        do {
            System.out.println("\n=== Criar Genero ===");
            System.out.print("Digite o nome do genero(ou 'sair' para finalizar): ");
            String nomeGenero = terminal.nextLine();

            // Se o usuário digitar "sair", o processo será interrompido
            if (nomeGenero.equalsIgnoreCase("sair")) {
                break;
            }

            // Cria um objeto Genero e tenta executá-lo através da ação CreateGeneroAction
            Genero genero = new Genero(nomeGenero);
            CreateGeneroAction action = new CreateGeneroAction(new CreateGeneroValidation());
            result = action.execute(genero);

            // Exibe a mensagem de resultado da ação
            System.out.println(result.getMessage());

        } while (!result.isSuccess());  // Continua até o gênero ser criado com sucesso
    }
}

=========================

==========================
{src/view/genero/GeneroMenu.java}
package view.genero;

import view.commons.IScreen;
import view.commons.Screen;

import java.util.Scanner;

/**
 * Classe que representa o menu de opções para o gerenciamento de gêneros no sistema.
 * <p>
 * A classe oferece opções ao usuário para adicionar um novo gênero, listar os gêneros existentes ou voltar para o menu anterior.
 * Ela herda de {@link view.commons.Screen} e, através do método {@link #draw(Scanner)}, exibe as opções de interação no terminal.
 * </p>
 */
public class GeneroMenu extends Screen {

    /**
     * Exibe o menu de opções para o gerenciamento de gêneros. O usuário pode escolher entre:
     * <ul>
     *     <li>Adicionar Gênero</li>
     *     <li>Listar Gêneros</li>
     *     <li>Voltar</li>
     * </ul>
     * O processo de interação continua até o usuário escolher a opção "Voltar".
     *
     * @param terminal o objeto {@link Scanner} utilizado para ler as entradas do usuário
     */
    @Override
    public void draw(Scanner terminal) {
        String opcao;
        do {
            // Exibe as opções de menu
            System.out.println("\n=== Gênero ===");
            System.out.println("1. Adicionar Gênero");
            System.out.println("2. Listar Gêneros");
            System.out.println("3. Voltar");
            System.out.print("Escolha uma opção: ");

            // Lê a opção selecionada pelo usuário
            opcao = terminal.nextLine();
            switch (opcao) {
                case "1":
                    // Chama o formulário para adicionar um novo gênero
                    new CreateGeneroForm().draw(terminal);
                    break;
                case "2":
                    // Chama o formulário para listar os gêneros existentes
                    new ListGenero().draw(terminal);
                    break;
                case "3":
                    // Finaliza a interação (volta para o menu anterior)
                    return;
                default:
                    // Mensagem para opções inválidas
                    System.out.println("Opção inválida. Tente novamente.");
            }
        } while (!opcao.equals("3"));  // Continua até o usuário escolher "Voltar"
    }
}

=========================

==========================
{src/view/genero/ListGenero.java}
package view.genero;

import controller.dataBase.GeneroRepository;
import model.Genero;
import view.commons.IScreen;

import java.util.Scanner;

/**
 * Classe responsável por listar todos os gêneros cadastrados no sistema.
 * <p>
 * Ela implementa a interface {@link view.commons.IScreen}, o que significa que ela exibe informações de uma tela (neste caso, a lista de gêneros).
 * O método {@link #draw(Scanner)} é responsável por buscar os gêneros no repositório e exibi-los no terminal.
 * </p>
 */
public class ListGenero implements IScreen {

    /**
     * Exibe todos os gêneros cadastrados no sistema no terminal.
     * Para cada gênero, é mostrado seu ID e nome.
     * Após exibir a lista, o usuário é instruído a pressionar Enter para continuar.
     *
     * @param terminal o objeto {@link Scanner} utilizado para ler as entradas do usuário
     */
    @Override
    public void draw(Scanner terminal) {
        // Obtém a instância do repositório de gêneros
        GeneroRepository generoRepository = GeneroRepository.getInstance();

        // Exibe o título da tela
        System.out.println("\n=== Listar Gêneros ===");

        // Percorre todos os gêneros armazenados no repositório e exibe seu ID e nome
        for (Genero g : generoRepository.getItems()) {
            System.out.println(g.getId() + " - " + g.getNome());
        }

        // Solicita que o usuário pressione Enter para continuar
        System.out.print("Pressione Enter para continuar...");
        terminal.nextLine();  // Aguarda a entrada do usuário
    }
}

=========================

==========================
{src/view/livro/CreateLivroForm.java}
package view.livro;

import controller.action.ActionResult;
import controller.action.livro.CreateLivroAction;
import controller.action.livro.CreateLivroValidation;
import controller.dataBase.GeneroRepository;
import model.Livro;
import model.Genero;
import view.commons.Screen;
import view.commons.ViewCommons;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Scanner;

/**
 * Tela para criação de um novo livro no sistema.
 * <p>
 * A classe coleta informações sobre o livro, como título, autor, editora, ISBN,
 * ano de lançamento, gêneros, se o livro foi consumido, e se o usuário possui ou já leu o livro.
 * Depois de criar o livro, o mesmo é registrado no sistema e o resultado da operação é mostrado.
 * </p>
 */
public class CreateLivroForm extends Screen {

    /**
     * Exibe o formulário para a criação de um livro e coleta as informações do usuário.
     * <p>
     * Caso não haja gêneros cadastrados no sistema, o usuário é informado para cadastrar um
     * gênero antes de criar o livro.
     * </p>
     * @param terminal O objeto Scanner usado para capturar entradas do usuário
     */
    @Override
    public void draw(Scanner terminal) {
        // Verifica se há gêneros cadastrados no sistema
        if (GeneroRepository.getInstance().getItems().isEmpty()) {
            System.out.println("Nenhum genero cadastrado. Cadastre um genero antes de criar um livro.");
            return;
        }

        ActionResult result;  // Armazenará o resultado da operação
        Livro livro;          // Instância do livro que será criada

        do {
            // Exibe o título da tela de criação de livro
            System.out.println("\n=== Criar Livro ===\n");

            // Coleta as informações sobre o livro
            System.out.print("Título do livro: ");
            String nome = terminal.nextLine();

            System.out.print("Autor: ");
            String autor = terminal.nextLine();

            System.out.print("Editora: ");
            String editora = terminal.nextLine();

            System.out.print("ISBN: ");
            String isbn = terminal.nextLine();

            // Solicita o ano de lançamento
            int anoLancamento = ViewCommons.inputAno(terminal, "Ano de Lançamento");

            // Coleta os gêneros do livro
            List<Genero> generosLivro = ViewCommons.inputGenero(terminal);

            // Pergunta se o livro foi lido e se o usuário possui o livro
            boolean consumido = ViewCommons.inputBoolean(terminal, "Já Leu? ");
            boolean possui = ViewCommons.inputBoolean(terminal, "Possui? ");

            // Criação do livro com os dados coletados
            livro = new Livro(nome, LocalDateTime.of(anoLancamento, 1, 1, 0, 0),
                    consumido, generosLivro, autor, editora, possui, isbn);

            System.out.println(livro.getTitulo());

            // Criação do objeto que executa a ação de salvar o livro
            CreateLivroAction createLivro = new CreateLivroAction(new CreateLivroValidation());
            result = createLivro.execute(livro);  // Executa a ação de criação

            // Exibe o resultado da operação (sucesso ou falha)
            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess());  // Repete até a criação do livro ser bem-sucedida

        // Exibe a tela com as informações do livro criado
        new LivroDisplay(livro).draw(terminal);
    }
}

=========================

==========================
{src/view/livro/LivroDisplay.java}
package view.livro;

import controller.dataBase.LivroRepository;
import model.Livro;
import view.avaliacao.AvaliacaoDisplay;
import view.avaliacao.CreateAvaliacaoForm;
import view.commons.Screen;

import java.util.Scanner;

/**
 * Exibe os detalhes de um livro, incluindo informações como título, autor, ISBN,
 * ano de lançamento, avaliação e ações possíveis (editar, avaliar, voltar).
 * Permite ao usuário interagir com o livro, editá-lo, avaliá-lo ou voltar ao menu anterior.
 */
public class LivroDisplay extends Screen {

    /**
     * O livro cujos detalhes serão exibidos.
     */
    private final Livro livro;

    /**
     * Construtor para a classe LivroDisplay.
     *
     * @param livro O livro cujos detalhes serão exibidos.
     */
    public LivroDisplay(Livro livro) {
        this.livro = livro;
    }

    /**
     * Exibe os detalhes do livro e permite ao usuário realizar ações como
     * editar o livro, avaliá-lo (se já foi lido) ou voltar ao menu anterior.
     *
     * @param terminal O objeto Scanner usado para capturar a entrada do usuário.
     */
    @Override
    public void draw(Scanner terminal) {
        // Exibe os detalhes do livro
        System.out.println("\n=== Detalhes do Livro ===");
        System.out.println("Título: " + livro.getTitulo());
        System.out.println("ISBN: " + livro.getIsbn());
        System.out.println("Autor: " + livro.getAutor());
        System.out.println("Possui Exemplar: " + (livro.isPossui() ? "Sim" : "Não"));
        System.out.println("Pontuação: " + livro.getPontuacao());
        System.out.println("Ano de Lançamento: " + livro.getDataLancamento().getYear());
        System.out.println("Gêneros: " + String.join(", ", livro.getGeneros().stream().map(g -> g.getNome()).toList()));
        System.out.println("Já li: " + (livro.isConsumido() ? "Sim" : "Não"));

        // Exibe as avaliações, se houver
        System.out.println("\n=== Avaliações ===");
        if (livro.getAvaliacoes().isEmpty()) {
            System.out.println("Nenhuma avaliação ainda.");
        } else {
            System.out.println("======================================");
            livro.getAvaliacoes().forEach(avaliacao -> {
                new AvaliacaoDisplay(avaliacao).draw();
                System.out.println("======================================");
            });
        }

        // Exibe o menu de ações
        System.out.println("\n=== Ações ===");
        System.out.println("1. Editar");
        System.out.println("2. Avaliar");
        System.out.println("3. Voltar");

        // Lê a opção do usuário
        String input;
        do {
            System.out.print("Escolha uma opção: ");
            input = terminal.nextLine();
            LivroRepository livroRepository = LivroRepository.getInstance();

            switch (input) {
                case "1":
                    // Edita o livro
                    new UpdateLivroForm(livro).draw(terminal);
                    new LivroDisplay(LivroRepository.getInstance().getItemById(livro.getId())).draw(terminal);
                    return;
                case "2":
                    // Avalia o livro, se já foi lido
                    if (!livro.isConsumido()) {
                        System.out.println("Você precisa ler o livro antes de avaliá-lo.");
                    } else {
                        CreateAvaliacaoForm createAvaliacaoForm = new CreateAvaliacaoForm();
                        createAvaliacaoForm.setObjAvaliavel(livro);
                        createAvaliacaoForm.draw(terminal);
                        Livro livroAvaliado = livroRepository.getItemById(livro.getId());
                        new LivroDisplay(livroAvaliado).draw(terminal);
                        return;
                    }
                    break;
                case "3":
                    // Volta para o menu anterior
                    break;
                default:
                    // Opção inválida
                    System.out.println("Opção inválida.");
            }
        } while (!input.equals("3"));
    }
}

=========================

==========================
{src/view/livro/LivroListMidia.java}
package view.livro;

import controller.search.SearchResults;
import model.Livro;
import view.ListMidia;
import view.SearchView;
import view.filme.FilmeDisplay;
import view.filme.FilmeListMidia;
import view.filme.SearchViewFilme;

import java.util.Scanner;

/**
 * Classe responsável por exibir a lista de livros e permitir ações de busca e exibição dos detalhes de um livro.
 * Estende a classe {@link ListMidia} para aproveitar o comportamento genérico da lista de mídias, adaptando-o para o caso dos livros.
 */
public class LivroListMidia extends ListMidia {

    /**
     * Construtor que inicializa a lista de livros com os resultados da busca.
     *
     * @param searchResults Os resultados da busca que serão exibidos.
     */
    public LivroListMidia(SearchResults searchResults) {
        super(searchResults);
    }

    /**
     * Exibe a tela de busca de livros.
     *
     * @param terminal O scanner para capturar a entrada do usuário.
     */
    @Override
    public void goToSearch(Scanner terminal) {
        SearchView searchView = new SearchViewLivro();
        LivroListMidia livroListMidia = new LivroListMidia(searchView.draw(terminal));
        livroListMidia.draw(terminal);
    }

    /**
     * Exibe os detalhes de um livro selecionado a partir da lista de mídias.
     *
     * @param terminal O scanner para capturar a entrada do usuário.
     * @param id O ID do livro a ser exibido.
     */
    @Override
    public void goToDisplay(Scanner terminal, int id) {
        new LivroDisplay((Livro) medias.get(id)).draw(terminal);
    }

    /**
     * Retorna o nome da mídia, que neste caso é "Livro".
     *
     * @return O nome da mídia ("Livro").
     */
    @Override
    public String getNomeMidia() {
        return "Livro";
    }
}

=========================

==========================
{src/view/livro/SearchViewLivro.java}
package view.livro;

import controller.filter.FilterChain;
import controller.search.SearchFields;
import controller.search.livro.SearchLivroController;
import controller.search.SearchResults;
import view.SearchView;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.List;

/**
 * A classe responsável por exibir a interface de busca específica para livros.
 * Estende a classe {@link SearchView} para fornecer uma busca personalizada para livros, com filtros e campos específicos.
 */
public class SearchViewLivro extends SearchView {

    /**
     * Lista de campos que podem ser usados para a busca de livros.
     */
    private List<AbstractMap.SimpleEntry<String, SearchFields>> fields = new ArrayList<>();

    /**
     * Retorna a lista de campos de busca disponíveis para livros.
     * Os campos incluem: "Tudo", "Título", "Gênero", "Ano de Lançamento", "Autor", "Duração" e "ISBN".
     *
     * @return A lista de campos de busca disponíveis para livros.
     */
    @Override
    public List<AbstractMap.SimpleEntry<String, SearchFields>> getFields() {
        fields.add(new AbstractMap.SimpleEntry<>("Tudo", SearchFields.TUDO));
        fields.add(new AbstractMap.SimpleEntry<>("Título", SearchFields.TITULO));
        fields.add(new AbstractMap.SimpleEntry<>("Gênero", SearchFields.GENERO));
        fields.add(new AbstractMap.SimpleEntry<>("Ano de Lançamento", SearchFields.ANO_LANCAMENTO));
        fields.add(new AbstractMap.SimpleEntry<>("Autor", SearchFields.AUTOR));
        fields.add(new AbstractMap.SimpleEntry<>("Duração", SearchFields.DURACAO));
        fields.add(new AbstractMap.SimpleEntry<>("ISBN", SearchFields.ISBN));

        return fields;
    }

    /**
     * Executa a busca de livros com base nos filtros fornecidos.
     * Utiliza o controlador {@link SearchLivroController} para realizar a busca e aplicar filtros.
     *
     * @param field O campo de busca selecionado (ex: "Título", "Gênero", etc.).
     * @param filterChain A cadeia de filtros a ser aplicada na busca.
     * @param value O valor de busca a ser utilizado no campo selecionado.
     * @param ordenacao Indica se os resultados devem ser ordenados.
     * @return Os resultados da busca encapsulados em um objeto {@link SearchResults}.
     */
    @Override
    public SearchResults execute(SearchFields field, FilterChain filterChain, String value, boolean ordenacao) {
        SearchLivroController searchLivroController = new SearchLivroController(value, field);
        searchLivroController.setFilterChain(filterChain);
        searchLivroController.setOrdenacao(ordenacao);
        searchLivroController.execute();
        SearchResults searchResults = searchLivroController.getSearchResults();
        return searchResults;
    }
}

=========================

==========================
{src/view/livro/UpdateLivroForm.java}
package view.livro;

import controller.action.ActionResult;
import controller.action.livro.UpdateLivroAction;
import controller.action.livro.UpdateLivroValidation;
import model.Livro;
import view.commons.Screen;
import view.commons.ViewCommons;

import java.util.Scanner;

/**
 * Classe responsável pela exibição do formulário de edição de um livro existente.
 * Permite que o usuário atualize informações como o status de leitura e posse do livro.
 */
public class UpdateLivroForm extends Screen {
    private final Livro livro;

    /**
     * Construtor que inicializa o formulário de edição com o livro que será alterado.
     *
     * @param livro O livro a ser editado.
     */
    public UpdateLivroForm(Livro livro) {
        this.livro = livro;
    }

    /**
     * Exibe o formulário de edição do livro e permite ao usuário atualizar o status de leitura e posse do livro.
     * O formulário continua a ser exibido até que a atualização seja bem-sucedida.
     *
     * @param terminal O scanner utilizado para capturar a entrada do usuário no terminal.
     */
    @Override
    public void draw(Scanner terminal) {
        ActionResult result;
        System.out.println("\n=== Editar Livro ===");

        do {
            // Solicita ao usuário as informações sobre o status de leitura e posse do livro
            boolean consumido = ViewCommons.inputBoolean(terminal, "Já Lido?");
            boolean possui = ViewCommons.inputBoolean(terminal, "\nPossui exemplar?");

            // Atualiza o livro com as novas informações
            livro.setConsumido(consumido);
            livro.setPossui(possui);

            // Executa a ação de atualização do livro
            UpdateLivroAction updateLivro = new UpdateLivroAction(new UpdateLivroValidation());
            result = updateLivro.execute(livro);

            // Exibe o resultado da operação
            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess()); // Continua até a operação ser bem-sucedida
    }
}

=========================

==========================
{src/view/serie/CreateSerieForm.java}
package view.serie;

import controller.action.serie.CreateSerieValidation;
import controller.dataBase.GeneroRepository;
import controller.action.serie.CreateSerieAction;
import controller.action.ActionResult;
import model.Serie;
import model.Genero;
import view.commons.Screen;
import view.commons.ViewCommons;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Scanner;

public class CreateSerieForm extends Screen {
    //todo: Testar to com muito sono para ver se funciona
    @Override
    public void draw(Scanner terminal) {
        if (GeneroRepository.getInstance().getItems().isEmpty()) {
            System.out.println("Nenhum genero cadastrado. Cadastre um genero antes de criar uma série.");
            return;
        }

        ActionResult result;
        Serie serie;

        do {
            System.out.println("\n=== Criar Série ===\n");
            System.out.print("Titulo da série: ");
            String nome = terminal.nextLine();
            System.out.print("Titulo Original: ");
            String nomeOriginal = terminal.nextLine();

            int anoLancamento = ViewCommons.inputAno(terminal, "Ano de Lançamento");
            int datafim = ViewCommons.inputAno(terminal, "Ano de Encerramento");
            System.out.print("Local disponível: ");
            String localDisponivel = terminal.nextLine();

            List<Genero> generosSerie = ViewCommons.inputGenero(terminal);
            List<String> elenco = ViewCommons.inputElenco(terminal);

            boolean consumido = ViewCommons.inputBoolean(terminal, "Já Assisti? ");

            serie = new Serie(nome, LocalDateTime.of(anoLancamento, 1, 1, 0, 0),
                    consumido, generosSerie, nomeOriginal, localDisponivel,
                    elenco, LocalDateTime.of(datafim, 1, 1, 0, 0));
            CreateSerieAction createSerie = new CreateSerieAction(new CreateSerieValidation());
            result = createSerie.execute(serie);

            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess());

       new SerieDisplay(serie).draw(terminal);
    }
}

=========================

==========================
{src/view/serie/SearchViewSerie.java}
package view.serie;

import controller.filter.FilterChain;
import controller.search.SearchFields;
import controller.search.SearchResults;
import controller.search.serie.SearchSerieController;
import view.SearchView;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.List;

public class SearchViewSerie extends SearchView {
    List<AbstractMap.SimpleEntry<String, SearchFields>> fields = new ArrayList<>();


    @Override
    public List<AbstractMap.SimpleEntry<String, SearchFields>> getFields() {
        fields.add(new AbstractMap.SimpleEntry<>("Tudo", SearchFields.TUDO));
        fields.add(new AbstractMap.SimpleEntry<>("Título", SearchFields.TITULO));
        fields.add(new AbstractMap.SimpleEntry<>("Gênero", SearchFields.GENERO));
        fields.add(new AbstractMap.SimpleEntry<>("Ano de Lançamento", SearchFields.ANO_LANCAMENTO));
        fields.add(new AbstractMap.SimpleEntry<>("Elenco", SearchFields.ELENCO));

        return fields;
    }

    @Override
    public SearchResults execute(SearchFields field, FilterChain filterChain, String value, boolean ordenacao) {
        SearchSerieController searchSerieController = new SearchSerieController(value, field);
        searchSerieController.setFilterChain(filterChain);
        searchSerieController.setOrdenacao(ordenacao);
        searchSerieController.execute();
        SearchResults searchResults = searchSerieController.getSearchResults();
        return searchResults;
    }
}

=========================

==========================
{src/view/serie/SerieDisplay.java}
package view.serie;

import controller.dataBase.SerieRepository;
import model.Serie;
import view.commons.Screen;
import view.commons.ViewCommons;
import view.serie.temporada.CreateTemporadaForm;
import view.serie.temporada.TemporadaDisplay;


import java.util.Scanner;

public class SerieDisplay extends Screen {
    private final Serie serie;
    
    
    public SerieDisplay(Serie serie) {
        this.serie = serie;
    }

    @Override
    public void draw(Scanner terminal) {
        System.out.println("\n=== Detalhes da Serie ===");
        System.out.println("Título " + serie.getTitulo());
        System.out.println("Título Original: " + serie.getTituloOriginal());
        System.out.println("Pontuação: " + serie.getPontuacao());
        System.out.println("Ano de Lançamento: " + serie.getDataLancamento().getYear());
        System.out.println("Ano de Encerramento: " + serie.getDataFim());
        System.out.println("Gêneros: " + String.join(", ", serie.getGeneros().stream().map(g -> g.getNome()).toList()));
        System.out.println("Elenco: " + String.join(", ", serie.getElenco()));
        System.out.println("Local Disponível: " + serie.getLocalDisponivel());
        System.out.println("Já assisti: " + (serie.isConsumido() ? "Sim" : "Não"));


        System.out.println("\n=== Temporadas ===");
        if (serie.getTemporadas().isEmpty()) {
            System.out.println("Nenhuma Temporada cadastrada.");
        } else {
            System.out.println("======================================");
            serie.getTemporadas().forEach(temporada -> {
                new TemporadaDisplay(temporada).draw();
                System.out.println("======================================");
            });
        }



        System.out.println("\n=== Ações ===");
        System.out.println("1. Editar");
        System.out.println("2. Adicionar Temporada");
        System.out.println("3. Selecionar Temporada");
        System.out.println("4. Voltar");

        String input;
        do {
            System.out.print("Escolha uma opção: ");
            input = terminal.nextLine();

            switch (input) {
                case "1":
                    new UpdateSerieForm(serie).draw(terminal);
                    new SerieDisplay(SerieRepository.getInstance().getItemById(serie.getId())).draw(terminal);
                    return;

                case "2":
                    new CreateTemporadaForm(serie).draw(terminal);
                    new SerieDisplay(SerieRepository.getInstance().getItemById(serie.getId())).draw(terminal);
                    return;

                case "3":
                    if (serie.getTemporadas().isEmpty()) {
                        System.out.println("Nenhuma temporada cadastrada.");
                        break;
                    }

                    do {
                        int id = ViewCommons.inputInt(terminal, "Digite o id da temporada: ");
                        if (serie.getTemporadas().stream().anyMatch(temporada -> temporada.getId() == id)) {
                            new TemporadaDisplay(serie.getTemporadaById(id)).draw(serie,terminal);
                            new SerieDisplay(SerieRepository.getInstance().getItemById(serie.getId())).draw(terminal);
                        } else {
                            System.out.println("Temporada não encontrada.");
                            break;
                        }
                    } while (true);
                    break;

                case "4":
                    return;

                default:
                    System.out.println("Opção inválida.");
            }
        } while (!input.equals("3"));


    }
}

=========================

==========================
{src/view/serie/SerieListMidia.java}
package view.serie;

import controller.search.SearchResults;
import model.Livro;
import model.Serie;
import view.ListMidia;
import view.SearchView;
import view.livro.LivroDisplay;

import java.util.Scanner;

public class SerieListMidia extends ListMidia {
    public SerieListMidia(SearchResults searchResults) {
        super(searchResults);
    }

    @Override
    public void goToSearch(Scanner terminal) {
        SearchView searchView = new SearchViewSerie();
        SerieListMidia serieListMidia =  new SerieListMidia(searchView.draw(terminal));
        serieListMidia.draw(terminal);
    }

    @Override
    public void goToDisplay(Scanner terminal, int id) {
        new SerieDisplay((Serie) medias.get(id)).draw(terminal);
    }

    @Override
    public String getNomeMidia() {
        return "Serie";
    }
}

=========================

==========================
{src/view/serie/UpdateSerieForm.java}
package view.serie;

import controller.action.ActionResult;
import controller.action.serie.UpdateSerieAction;
import controller.action.serie.UpdateSerieValidation;
import model.Serie;
import view.commons.Screen;
import view.commons.ViewCommons;

import java.util.Scanner;

public class UpdateSerieForm extends Screen {
    Serie serie;

    public UpdateSerieForm(Serie serie) {
        this. serie =  serie;
    }

    @Override
    public void draw(Scanner terminal) {
        ActionResult result;
        System.out.println("\n=== Editar Serie ===");
        do {
            boolean consumido = ViewCommons.inputBoolean(terminal, "Já Assisti?");

            serie.setConsumido(consumido);
            UpdateSerieAction updateSerie = new UpdateSerieAction(new UpdateSerieValidation());
            result = updateSerie.execute(serie);

            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess());
    }
}

=========================

==========================
{src/view/serie/temporada/CreateTemporadaForm.java}
package view.serie.temporada;

import controller.action.ActionResult;
import controller.action.temporada.CreateTemporadaAction;
import controller.action.temporada.CreateTemporadaValidation;
import model.Serie;
import model.Temporada;
import view.commons.Screen;
import view.commons.ViewCommons;
import view.serie.SerieDisplay;

import java.time.LocalDateTime;
import java.util.Scanner;

public class CreateTemporadaForm extends Screen {
    private Serie serie;
    private ActionResult result;

    public CreateTemporadaForm( Serie serie) {
        this.serie = serie;
    }

    @Override
    public void draw(Scanner terminal) {
        do {
            System.out.println("\n=== Adicionar Temporada ===");

            int ano = ViewCommons.inputAno(terminal, "Digite o ano da temporada");
            int qEpisodios = ViewCommons.inputInt(terminal, "Digite a quantidade de episodios: ");

            Temporada temporada = new Temporada(qEpisodios,
                    LocalDateTime.of(ano, 1, 1, 0, 0));

            CreateTemporadaAction createTemporadaAction = new CreateTemporadaAction(new CreateTemporadaValidation());
            createTemporadaAction.setSuperModel(serie);
            result = createTemporadaAction.execute(temporada);

            System.out.println("\n=== Resultado: " + result.getMessage());

        } while (!result.isSuccess());

        new SerieDisplay(serie).draw(terminal);
    }
}

=========================

==========================
{src/view/serie/temporada/TemporadaDisplay.java}
package view.serie.temporada;

import model.Serie;
import model.Temporada;
import view.avaliacao.AvaliacaoDisplay;
import view.avaliacao.CreateAvaliacaoForm;

import java.util.Scanner;

public class TemporadaDisplay {
    Temporada temporada;

    public TemporadaDisplay(Temporada temporada) {
        this.temporada = temporada;
    }

    public void draw() {
        System.out.println("Ano da temporada: " + temporada.getAno().getYear());
        System.out.println("--------------------");
        System.out.println("Id: " + temporada.getId());
        System.out.println("Pontuação: " + temporada.getPontuacao());
        System.out.println("Quantidade episodios: " + temporada.getqEpisodios());
    }

    public void draw(Serie serie, Scanner terminal) {
        String input;
        do {
            System.out.println("\n=== Detalhes da Temporada ===");
            draw();
            System.out.println("\n=== Avaliações ===");
            if (temporada.getAvaliacoes().isEmpty()) {
                System.out.println("Nenhuma avaliação ainda.");
            } else {
                System.out.println("======================================");
                temporada.getAvaliacoes().forEach(avaliacao -> {
                    new AvaliacaoDisplay(avaliacao).draw();
                    System.out.println("======================================");
                });
            }
            System.out.println("\n=== Ações ===");
            System.out.println("1. Avaliar");
            System.out.println("2. Voltar");


            System.out.print("Escolha uma opção: ");
            input = terminal.nextLine();

            switch (input) {
                case "1":{
                    if (!serie.isConsumido()) {
                        System.out.println("Você precisa assistir a serie antes de avaliá-la.");

                    } else {
                        CreateAvaliacaoForm createAvaliacaoForm = new CreateAvaliacaoForm();
                        createAvaliacaoForm.setObjAvaliavel(temporada);
                        createAvaliacaoForm.draw(terminal);
                        return;
                    }
                }
                break;
                case "2":
                    return;
                default:
                    System.out.println("Opção inválida.");
            }

        } while (!input.equals("2"));
    }
}

=========================

